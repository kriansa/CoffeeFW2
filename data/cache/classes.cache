<?php
/**
 * App class cache file
 * Do not edit this file directly, any changes will be overwritten
 * Created at Sun, 16 Sep 2012 00:35:45 -0300
 */

// File: <Core\Loader.php>
namespace Core;

class LoaderException extends \Exception {}

class Loader
{
	/**
	 * Default include path
	 * @var string
	 */
	protected static $_defaultIncludePath = null;

	/**
	 * The loaded packages
	 * @var array
	 */
	protected static $_packagesLoaded = [];

	/**
	 * Register the class autoloader
	 */
	public static function register()
	{
		// Register only once
		if (static::$_defaultIncludePath)
		{
			return;
		}

		static::$_defaultIncludePath = get_include_path();

		$include_path = array(
			realpath(APPPATH . 'classes'),
			realpath(COREPATH . 'classes'),
			static::$_defaultIncludePath,
		);

		set_include_path(implode(PATH_SEPARATOR, $include_path));

		spl_autoload_register('Core\\Loader::loadClass');
	}

	/**
	 * Adds packages to the autoloader
	 *
	 * @param array|ArrayAccess $packages
	 * @throws \Core\LoaderException
	 */
	public static function addPackages($packages)
	{
		if (!is_array($packages) or ! $packages instanceof \ArrayAccess)
		{
			throw new LoaderException('Packages must be an Array or a ArrayAccess object');
		}

		$path_packages = [];
		foreach ($packages as $package)
		{
			$package = ucfirst($package);

			if (!$package)
			{
				throw new LoaderException('Package ' . $package . ' not found!');
			}

			if (isset(static::$_packagesLoaded[$package]))
			{
				throw new LoaderException('Package ' . $package . ' already loaded!');
			}

			$path_packages[] = realpath(PKGPATH . $package . DS . 'classes');
			static::$_packagesLoaded[$package] = true;
		}

		$include_path = [
			realpath(APPPATH . 'classes'),
			implode(PATH_SEPARATOR, $path_packages + static::$_packagesLoaded),
			realpath(COREPATH . 'classes'),
			static::$_defaultIncludePath,
		];

		set_include_path(implode(PATH_SEPARATOR, $include_path));
	}

	/**
	 * Adds a package to the autoloader
	 *
	 * @param string $package_name
	 * @throws \Core\LoaderException
	 */
	public static function addPackage($package_name)
	{
		$package_name = ucfirst($package_name);
		$path = PKGPATH . $package_name . DS . 'classes';

		if ( ! is_dir($path))
		{
			throw new LoaderException('Package ' . $package_name . ' not found!');
		}

		if (isset(static::$_packagesLoaded[$package_name]))
		{
			throw new LoaderException('Package ' . $package_name . ' already loaded!');
		}

		static::$_packagesLoaded[$package_name] = true;
		$include_path = explode(PATH_SEPARATOR, get_include_path());
		array_splice($include_path, 1, 0, $path);

		set_include_path(implode(PATH_SEPARATOR, $include_path));
	}

	/**
	 * Load a class
	 *
	 * @param string $class
	 * @return bool
	 */
	public static function loadClass($class)
	{
		// Already loaded
		if (strpos($class, 'static::') !== false)
		{
			return true;
		}

		include static::getClassFile($class);

		// Init the class
		if (method_exists($class, '_init'))
		{
			$class::_init();
		}

		return true;
	}

	/**
	 * Get the filename of a given class
	 *
	 * @param string $class
	 * @return string
	 */
	public static function getClassFile($class)
	{
		$fileName = '';

		if (false !== ($lastNsPos = strripos($class, '\\')))
		{
			$namespace = substr($class, 0, $lastNsPos);
			$class = substr($class, $lastNsPos + 1);
			$fileName = str_replace('\\', DS, $namespace) . DS;
		}

		return $fileName . str_replace('_', DS, $class) . '.php';
	}
}
// End of file: <Core\Loader.php>

// File: <Core\LoaderException.php>

// End of file: <Core\LoaderException.php>

// File: <Core\ConfigException.php>

// End of file: <Core\ConfigException.php>

// File: <Core\Config.php>
namespace Core;

class ConfigException extends \Exception {}

class Config
{
	/**
	 * The master config array
	 * @var array
	 */
	public static $items = array();

	/**
	 * Loads a config file.
	 *
	 * @param string|array $file string File | Config array
	 * @param bool $overwrite
	 * @return bool
	 */
	public static function load($file, $overwrite = false)
	{
		if ( ! $overwrite and
		     ! is_array($file) and
		    array_key_exists(($file = strtolower($file)), static::$items))
		{
			return false;
		}

		if (is_array($file))
		{
			$config = $file;
		}
		elseif (is_string($file))
		{
			$config = static::_mergeCascading(ucfirst($file) . '.php');
			static::$items[$file] = true;
		}
		else
		{
			return false;
		}

		! empty($config) and static::$items[$file] = $config;

		return true;
	}

	/**
	 * Returns a (dot notated) config setting
	 *
	 * @param string $item Name of the config item, can be dot notated
	 * @param mixed $default The return value if the item isn't found
	 * @return mixed The config setting or default if not found
	 */
	public static function get($item, $default = null)
	{
		$item = strtolower($item);
		$parts = explode('.', $item);
		$file = $parts[0];

		// Check if the file was loaded, and try to load it if not
		if( ! isset(static::$items[$file]))
		{
			static::load($file);
		}

		// Avoid some overhead in Arr::get
		switch (count($parts))
		{
			case 1:
				if (isset(static::$items[$item]))
				{
					return value(static::$items[$item]);
				}
			break;

			case 2:
				if (isset(static::$items[$parts[0]][$parts[1]]))
				{
					return value(static::$items[$parts[0]][$parts[1]]);
				}
			break;

			case 3:
				if (isset(static::$items[$parts[0]][$parts[1]][$parts[2]]))
				{
					return value(static::$items[$parts[0]][$parts[1]][$parts[2]]);
				}
			break;

			case 4:
				if (isset(static::$items[$parts[0]][$parts[1]][$parts[2]][$parts[3]]))
				{
					return value(static::$items[$parts[0]][$parts[1]][$parts[2]][$parts[3]]);
				}
			break;

			case 5:
				if (isset(static::$items[$parts[0]][$parts[1]][$parts[2]][$parts[3]][$parts[4]]))
				{
					return value(static::$items[$parts[0]][$parts[1]][$parts[2]][$parts[3]][$parts[4]]);
				}
			break;
		}

		return value(Arr::get(static::$items, $item, $default));
	}

	/**
	 * Sets a (dot notated) config item
	 *
	 * @param string A (dot notated) config key
	 * @param mixed The config value
	 */
	public static function set($item, $value)
	{
		Arr::set(static::$items, strtolower($item), value($value));
	}

	/**
	 * Deletes a (dot notated) config item
	 *
	 * @param string A (dot notated) config key
	 * @return array|bool The Arr::delete result, success boolean or array of success booleans
	 */
	public static function delete($item)
	{
		return Arr::delete(static::$items, $item);
	}

	/**
	 * Makes a recursive merge using the cascading file system
	 *
	 * @param string $fileName
	 * @return array Configs
	 */
	protected static function _mergeCascading($fileName)
	{
		$files = array();

		if(file_exists(APPPATH . 'Config' . DS . $fileName))
			$files[] = include(APPPATH . 'Config' . DS . $fileName);

		if(file_exists(APPPATH . 'Config' . DS . ENVIRONMENT . DS . $fileName))
			$files[] = include(APPPATH . 'Config' . DS . ENVIRONMENT . DS . $fileName);

		if(empty($files))
		{
			return array();
		}

		// Lets make as fast as we can! :)
		switch(count($files)){
			case 1:
				return $files[0];
			case 2:
				return Arr::merge($files[0], $files[1]);
		}
	}
}
// End of file: <Core\Config.php>

// File: <Core\Profiler.php>
namespace Core;

class Profiler
{
	/**
	 * Resource types of the profiler
	 */
	const MARK = 1;
	const MARK_MEMORY = 2;
	const DB_BENCHMARK = 3;
	const APP_STATS = 4;

	/**
	 * Whether the profiler is enabled or not
	 * @var bool
	 */
	protected static $_enabled = false;

	/**
	 * Store the last query
	 * @var string
	 */
	protected static $_query = null;

	/**
	 * Array with all the queries of the profiler
	 * @var array
	 */
	protected static $_queries = array();

	/**
	 * Array with all the time markpoints
	 * @var array
	 */
	public static $_marks = array();

	/**
	 * Array with all the memory markpoints
	 * @var array
	 */
	protected static $_memory_marks = array();

	/**
	 * Resources enabled or disabled
	 * @var array
	 */
	protected static $_resources = array(
		self::MARK => true,
		self::MARK_MEMORY => true,
		self::DB_BENCHMARK => true,
		self::APP_STATS => true,
	);

	/**
	 * Start the system and enable its resources
	 *
	 * @return void
	 */
	public static function _init()
	{
		if (static::$_enabled = (bool) Config::get('system.profiler.enabled'))
		{
			static::enableResources(Config::get('system.profiler.resources'));
			Event::register('before_send_headers', 'Core\\Profiler::send');
		}
	}

	/**
	 * Enable or disable profiler resources
	 *
	 * Ex: array(
	 *		Profiler::MARK => false,
	 *		Profiler::MARK_MEMORY => true,
	 * )
	 *
	 * @param array $resources
	 * @return void
	 */
	public static function enableResources(array $resources)
	{
		static::$_resources = $resources + static::$_resources;
	}

	/**
	 * Check if some resource is enabled
	 *
	 * @param int $resource
	 * @return bool
	 */
	public static function isEnabled($resource)
	{
		return static::$_enabled and static::$_resources[$resource] === true;
	}

	/**
	 * Start a timer mark
	 *
	 * @param string Name
	 * @return void
	 */
	public static function markStart($label)
	{
		static::isEnabled(static::MARK) and static::$_marks[$label] = array(
			'time' => microtime(true),
			'name' => $label,
			'stopped' => false,
		);
	}

	/**
	 * Stop a timer mark
	 *
	 * @param string Name
	 * @return void
	 */
	public static function markEnd($label)
	{
		static::isEnabled(static::MARK) and static::$_marks[$label] = array(
			'time' => (microtime(true) - static::$_marks[$label]['time']),
			'name' => $label,
			'stopped' => true,
		);
	}

	/**
	 * Set a mark status since the script start time
	 *
	 * @param string Name
	 * @return void
	 */
	public static function sinceStart($label)
	{
		static::isEnabled(static::MARK) and static::$_marks[$label] = array(
			'time' => (microtime(true) - APP_START_TIME),
			'name' => $label,
			'stopped' => true,
		);
	}

	/**
	 * Marks the memory usage of some variable
	 * If null, marks the memory usage of PHP at the moment of calling
	 *
	 * @param mixed $var Variable
	 * @param string $label Label
	 */
	public static function markMemory($var = null, $label = 'PHP')
	{
		if (static::isEnabled(static::MARK_MEMORY)) {
			$memory = $var ? strlen(serialize($var)) : memory_get_usage();
			static::$_memory_marks[] = array(
				'time' => microtime(true),
				'name' => $label,
				'memory' => $memory,
				'type' => Debug::getType($var),
			);
		}
	}

	/**
	 * Start the benchmark of some query
	 *
	 * @param string $dbname Database connection name
	 * @param string $sql SQL Query
	 * @param string $bindings SQL Bindings
	 * @return void
	 */
	public static function queryStart($dbname, $sql, $bindings)
	{
		if (static::isEnabled(static::DB_BENCHMARK))
		{
			static::$_query = array(
				'dbname' => $dbname,
				'sql' => $sql,
				'bindings' => $bindings,
				'time' => microtime(true),
			);
		}
	}

	/**
	 * Stop the benchmark of the last query and put into the queries array
	 *
	 * @return void
	 */
	public static function queryStop()
	{
		if (static::isEnabled(static::DB_BENCHMARK))
		{
			static::$_query['time'] = microtime(true) - static::$_query['time'];
			static::$_queries[] = static::$_query;
		}
	}

	/**
	 * Send the data to browser
	 * And displays the final stats
	 *
	 * @return void
	 */
	public static function send()
	{
		if (static::isEnabled(static::DB_BENCHMARK) and count(static::$_queries))
		{
			$table = array(array('DB', 'Time', 'SQL', 'Bindings'));
			foreach(static::$_queries as $query)
			{
				$table[] = array($query['dbname'], (string)round($query['time'], 4), $query['sql'], $query['bindings']);
			}
			Debug\FirePHP::getInstance()->table('Profiler - DB Benchmark', $table);
		}

		if (static::isEnabled(static::MARK_MEMORY) and count(static::$_memory_marks))
		{
			$table = array(array('Name', 'Type', 'Time', 'Memory'));
			foreach(static::$_memory_marks as $mark)
			{
				$table[] = array($mark['name'], $mark['type'], (string)round(($mark['time'] - APP_START_TIME), 4), (string)round($mark['memory'] / pow(1024, 2), 5) . 'MB');
			}
			Debug\FirePHP::getInstance()->table('Profiler - Memory', $table);
		}

		if (static::isEnabled(static::MARK) and count(static::$_marks))
		{
			$table = array(array('Name', 'Time'));
			foreach(static::$_marks as $mark)
			{
				if($mark['stopped'])
				{
					$table[] = array($mark['name'], (string)round($mark['time'], 4));
				}
			}
			// Only displays the time marks if they're finished
			count($table) > 2 and Debug\FirePHP::getInstance()->table('Profiler - Time marks', $table);
		}

		if (static::isEnabled(static::APP_STATS))
		{
			Debug\FirePHP::getInstance()->info('Execution time: ~' . round((microtime(true) - APP_START_TIME), 4) . ' - Memory usage: ' . round((memory_get_peak_usage() - APP_START_MEM) / pow(1024, 2), 3) . 'MB');
		}
	}
}
// End of file: <Core\Profiler.php>

// File: <Core\Event.php>
namespace Core;

/**
 * Default system events:
 *
 * - shutdown
 * - before_send_body
 * - before_send_headers
 *
 */
abstract class Event
{
	/**
	 * @var array An array of listeners
	 */
	protected static $_events = [];

	/**
	 * Register
	 *
	 * Registers a Callback for a given event
	 *
	 * @param string $event The name of the event
	 * @param Closure|callable $callback The callback function
	 * @param bool $first_on_callstack Whether to insert the callback on TOP of callstack
	 * @return bool
	 */
	public static function register($event, $callback, $first_on_callstack = false)
	{
		// if the arguments are valid, register the event
		if (isset($event) and is_string($event) and isset($callback) and is_callable($callback))
		{
			// make sure we have an array for this event
			isset(static::$_events[$event]) or static::$_events[$event] = array();

			// store the callback on the call stack
			if ($first_on_callstack)
			{
				static::$_events[$event][] = $callback;
			}
			else
			{
				array_unshift(static::$_events[$event], $callback);
			}

			// and report success
			return true;
		}

		// can't register the event
		return false;
	}

	/**
	 * Unregister/remove one or all callbacks from event
	 *
	 * @param string $event Event to remove from
	 * @param Closure|callable $callback Callback to remove [optional, null for all]
	 * @return bool Wether one or all callbacks have been removed
	 */
 	public static function unregister($event, $callback = null)
	{
		if (isset(static::$_events[$event]))
		{
			if ($callback === null)
			{
				static::$_events[$event] = array();
				return true;
			}

			foreach (static::$_events[$event] as $i => $arguments)
			{
				if($callback === $arguments)
				{
					unset(static::$_events[$event][$i]);
					return true;
				}
			}
		}

		return false;
	}

	/**
	 * Trigger
	 *
	 * Triggers an event and returns the results.  The results can be returned
	 * in the following formats:
	 *
	 * 'array'
	 * 'json'
	 * 'serialized'
	 * 'string'
	 *
	 * @param string $event The name of the event
	 * @param mixed $data Any data that is to be passed to the listener as an argument
	 * @param string $return_type The return type
	 * @param bool $reversed Wether to fire events ordered LIFO instead of FIFO
	 * @return mixed The return of the listeners, in the return type
	 */
	public static function trigger($event, $data = null, $return_type = 'array', $reversed = false)
	{
		$calls = array();

		// check if we have events registered
		if (static::hasEvents($event))
		{
			$events = $reversed ? array_reverse(static::$_events[$event], true) : static::$_events[$event];

			// process them
			foreach ($events as $event)
			{
				// call the callback event
				if (is_callable($event))
				{
					if (is_string($event) and strpos($event, '::') !== false)
					{
						$event = explode('::', $event);
					}

					$calls[] = $event($data);
				}
			}
		}

		switch ($return_type)
		{
			case 'array':
				return $calls;

			case 'json':
				return json_encode($calls);

			case 'none':
				return;

			case 'serialized':
				return serialize($calls);

			case 'string':
				$str = '';
				foreach ($calls as $call)
				{
					$str .= $call;
				}
				return $str;

			default:
				return $calls;
		}
	}

	/**
	 * Has Listeners
	 *
	 * Checks if the event has listeners
	 *
	 * @access public
	 * @param string $event The name of the event
	 * @return bool Whether the event has listeners
	 */
	public static function hasEvents($event)
	{
		if (isset(static::$_events[$event]) and count(static::$_events[$event]) > 0)
		{
			return true;
		}
		return false;
	}
}
// End of file: <Core\Event.php>

// File: <Core\Error.php>
namespace Core;

class Error
{
	/**
	 * All the error levels and their names
	 * @var array
	 */
	protected static $_errorLevels = array(
		0 => 'Error',
		E_ERROR => 'Fatal Error',
		E_WARNING => 'Warning',
		E_PARSE => 'Parsing Error',
		E_NOTICE => 'Notice',
		E_CORE_ERROR => 'Core Error',
		E_CORE_WARNING => 'Core Warning',
		E_COMPILE_ERROR => 'Compile Error',
		E_COMPILE_WARNING => 'Compile Warning',
		E_DEPRECATED => 'Deprecated',
		E_USER_DEPRECATED => 'Deprecated',
		E_USER_ERROR => 'User Error',
		E_USER_WARNING => 'User Warning',
		E_USER_NOTICE => 'User Notice',
		E_STRICT => 'Runtime Notice'
	);

	/**
	 * List of fatal errors
	 * @var array
	 */
	protected static $_fatalLevels = array(E_PARSE, E_ERROR, E_CORE_ERROR, E_USER_ERROR, E_COMPILE_ERROR);

	/**
	 * PHP Exception handler
	 *
	 * @param \Exception $exception The exception
	 */
	public static function exceptionHandler(\Exception $exception)
	{
		// Log all the errors
		Debug::log($exception);

		// And output them
		static::_output($exception);
	}

	/**
	 * PHP Error handler
	 *
	 * @param int $severity
	 * @param string $message
	 * @param string $filepath
	 * @param int $line
	 * @return bool
	 */
	public static function errorHandler($severity, $message, $file, $line)
	{
		// Log all the errors
		Debug::log($message, Debug::E_ERROR, $file, $line);

		// Always display fatal errors
		// Only output non-fatal errors when not in production
		if (in_array($severity, static::$_fatalLevels) or ENVIRONMENT !== 'production')
		{
			static::_output(new \ErrorException($message, $severity, 0, $file, $line));
		}

		return true;
	}

	/**
	 * Native PHP shutdown handler to catch the non-catchable fatal errors
	 *
	 * @return void
	 */
	public static function shutdownHandler()
	{
		$last_error = error_get_last();

		// Only show valid fatal errors
		if ($last_error and in_array($last_error['type'], static::$_fatalLevels))
		{
			// Log all the errors
			Debug::log($last_error['message'], Debug::E_ERROR, $last_error['file'], $last_error['line']);
			static::_output(new \ErrorException($last_error['message'], $last_error['type'], 0, $last_error['file'], $last_error['line']));
			die;
		}
	}

	/**
	 * Shows an error. It will stop script execution.
	 *
	 * @param \Exception $exception
	 * @return void
	 */
	protected static function _output(\Exception $exception)
	{
		// In production, output all non-fatal errors
		if (ENVIRONMENT === 'production')
		{
			if ($exception instanceof \ErrorException and ! in_array($exception->getCode(), static::$_fatalLevels))
			{
				Request::getInstance()->setBody(View::make('Error' . DS . 'error-production'))->setStatus(500)->send();
				die;
			}
		}
		// Ajax requests OR non-fatal ErrorExceptions: send the errors via FirePHP
		elseif (Input::isAjax() or ($exception instanceof \ErrorException and ! in_array($exception->getCode(), static::$_fatalLevels)))
		{
			// If it's fatal, then send the response and stop script
			// If sent as ErrorException, the code will contain the severity
			// If thrown as Exception or any inherited class, it should stop
			// Because its severity doesn't matter, it's suposed to be a
			// Normal exception, not a PHP Error
			if($exception instanceof \ErrorException and ! in_array($exception->getCode(), static::$_fatalLevels))
			{
				Debug\FirePHP::getInstance()->warn(Debug::cleanPath($exception->getFile()) . ' @ line: ' . $exception->getLine() . ' - ' . $exception->getMessage());
			}
			// Ajax errors are displayed in Firebug console
			else
			{
				Debug\FirePHP::getInstance()->fb($exception, Debug::cleanPath($exception->getFile()) . ' @ line: ' . $exception->getLine() . ' - ' . $exception->getMessage(), Debug\FirePHP::EXCEPTION);
				Request::getInstance()->setStatus(500)->send(false);
				die;
			}
		}
		else
		{
			Request::getInstance()->setBody(new View('Error' . DS . 'error-' . ENVIRONMENT, static::_formatException($exception), false))->setStatus(500)->send();
			die;
		}
	}

	/**
	 * Format a Exception object to output to the HTML
	 *
	 * @param \Exception $exception
	 * @return array Lines of HTML file
	 */
	protected static function _formatException(\Exception $exception)
	{
		$data = array(
			'type' => get_class($exception),
			'message' => $exception->getMessage(),
			'filepath' => Debug::cleanPath($exception->getFile()),
			'error_line' => $exception->getLine(),
			'backtrace' => $exception->getTrace(),
			'severity' => isset(static::$_errorLevels[$exception->getCode()]) ? static::$_errorLevels[$exception->getCode()] : $exception->getCode(),
			'debug_lines' => Debug::highlightFile($exception->getFile(), $exception->getLine()),
		);


		foreach ($data['backtrace'] as $key => $trace)
		{
			if ( ! isset($trace['file']) or $trace['file'] == COREPATH . 'Classes' . DS . 'Error.php')
			{
				unset($data['backtrace'][$key]);
			}
		}

		return $data;
	}
}
// End of file: <Core\Error.php>

// File: <Core\RequestException.php>

// End of file: <Core\RequestException.php>

// File: <Core\HttpNotFoundException.php>

// End of file: <Core\HttpNotFoundException.php>

// File: <Core\Request.php>
namespace Core;

class RequestException extends \Exception {}
class HttpNotFoundException extends \Exception {}

class Request
{
	/**
	 * Current request status
	 * @var int
	 */
	public $status = 200;

	/**
	 * Current content-type of the request
	 * [A key from Config::get('mimes')]
	 * @var string
	 */
	public $contentType = 'html';

	/**
	 * String with the full content to be sent
	 * @var string
	 */
	public $body = null;

	/**
	 * Current charset
	 * @var string
	 */
	public $charset = null;

	/**
	 * Array with all headers contents
	 * @var array
	 */
	protected $_headers = [];

	/**
	 * Array with all cookies to be sent
	 * @var array
	 */
	protected $_cookies = [];

	/**
	 * Cache directives
	 * @var array
	 */
	protected $_cacheDirectives = [];

	/**
	 * Singleton instance
	 * @var \Core\Request
	 */
	protected static $_instance = null;

	/**
	 * Gets the default charset
	 */
	public function __construct()
	{
		$this->charset = Config::get('system.encoding');
	}

	/**
	 * Gets the singleton instance
	 *
	 * @return \Core\Request  Retorna a instância ou cria caso ela não tenha sido iniciada
	 */
	public static function getInstance()
	{
		if (static::$_instance === null)
		{
			static::$_instance = new static;
		}

		return static::$_instance;
	}

	/**
	 * Create a new instance using factory pattern
	 *
	 * @return \Core\Request
	 */
	public static function make()
	{
		return new static;
	}

	/**
	 * Dispatch a route
	 *
	 * @param Route
	 * @return \Core\Request
	 * @throws \Core\HttpNotFoundException
	 */
	public function dispatch(Route $route = null)
	{
		Profiler::markStart(__METHOD__);

		if($route === null)
		{
			throw new HttpNotFoundException('Invalid route');
		}

		$params = $route->params;
		$controller = $route->controller;
		$action = $route->action . 'Action';

		// Try to autoload the class, otherwise, error 404!
		if ( ! class_exists($controller))
		{
			throw new HttpNotFoundException('Controller "' . $controller . '" not found');
		}

		if ( ! method_exists($controller, $action))
		{
			throw new HttpNotFoundException('Action "' . $action . '" not found');
		}

		// Autoload the session
		Config::get('system.session.autoload') and class_exists('Core\\Session');

		// Autoload the profiler
		Config::get('system.profiler.enabled') and class_exists('Core\\Profiler');

		// Create a new controller instance, and send two parameters
		// This Request instance and the params from Route
		/** @var $instance \Core\Controller\Complete */
		$instance = new $controller($this, $params);

		// Get the response from Controller::before first
		if (method_exists($controller, 'before'))
		{
			Profiler::markStart(' - ' . $controller . '::before');
			$response = $instance->before($action);
			Profiler::markEnd(' - ' . $controller . '::before');
		}
		else
		{
			$response = null;
		}

		// If the before method is the response OR false, then we don't execute the action and after methods
		if ($response !== false and ! is_string($response) and ! ($response instanceof Request))
		{
			// Execute the action
			Profiler::markStart(' - ' . $controller . '::' . $action);
			$response = $instance->$action($params);
			Profiler::markEnd(' - ' . $controller . '::' . $action);

			// The controller response will be re-sent to the Controller::after
			// Which must return the formatted body for layout and such things
			if (method_exists($controller, 'after'))
			{
				Profiler::markStart(' - ' . $controller . '::after');
				$response = $instance->after($response, $action);
				Profiler::markEnd(' - ' . $controller . '::after');
			}
		}

		// If the response is a Request object, lets replace our by its
		if ($response instanceof Request)
		{
			foreach (get_object_vars($response) as $key => $value)
			{
				$this->$key = $value;
			}
		}
		else
		{
			$this->body = (string) $response;
		}

		Profiler::markEnd(__METHOD__);
		return $this;
	}

	/**
	 * Redirect user to another URL
	 *
	 * @param string $url The url
	 * @param string $method 'location' or 'refresh'
	 * @param int $code Status code
	 */
	public static function redirect($url = '', $method = 'location', $code = 302)
	{
		$request = static::getInstance();

		$request->status = $code;

		if (strpos($url, '://') === false)
		{
			$url = $url !== '' ? URL::create($url) : URL::getBase();
		}

		if ($method === 'location')
		{
			$request->setHeader('Location', $url);
		}
		elseif ($method === 'refresh')
		{
			$request->setHeader('Refresh', '0;url='.$url);
		}
		else
		{
			return;
		}

		$request->_sendHeaders();

		exit;
	}

	/**
	 * Set the Content Type of this request
	 *
	 * @param string $contentType
	 * @return \Core\Request
	 */
	public function setContentType($contentType)
	{
		$this->contentType = $contentType;
		return $this;
	}

	/**
	 * Return the current Content Type of request
	 *
	 * @return string
	 */
	public function getContentType()
	{
		return $this->contentType;
	}

	/**
	 * Sets the request charset
	 *
	 * @param string $charset
	 * @return \Core\Request
	 */
	public function setCharset($charset)
	{
		$this->charset = $charset;
		return $this;
	}

	/**
	 * Return the current charset
	 *
	 * @return string
	 */
	public function getCharset()
	{
		return $this->charset;
	}

	/**
	 * Get the configs of a current cookie to be sent
	 *
	 * @param string $cookie
	 * @return array
	 */
	public function getCookie($cookie)
	{
		if ( ! isset($this->_cookies[$cookie]))
			return null;

		return $this->_cookies[$cookie];
	}

	/**
	 * Set a cookie
	 *
	 * @param array $options
	 * @return \Core\Request $this
	 */
	public function setCookie($options)
	{
		$defaults = [
			'name' => 'CoffeeCookie',
			'value' => '',
			'expire' => 0,
			'path' => '/',
			'domain' => '',
			'secure' => false,
			'http_only' => false,
		];
		$options += $defaults;

		$this->_cookies[$options['name']] = $options;

		return $this;
	}

	/**
	 * Sets the correct headers to instruct the client to cache the request.
	 *
	 * @param string $since a valid time since the request text has not been modified
	 * @param string|int $time a valid time recognizable by strtotime or timestamp for cache expiry
	 * @return \Core\Request $this
	 */
	public function setCache($since = 'now', $time = '+1 day')
	{
		if ( ! is_int($time))
		{
			$time = strtotime($time);
		}
		$this->_headers['Date'] = gmdate("D, j M Y H:i:s \G\M\T");
		$this->setLastModified($since);
		$this->setExpires($time);
		$this->setSharable(true);
		$this->setMaxAge($time - time());

		return $this;
	}

	/**
	 * Sets whether a response is eligible to be cached by intermediate proxies
	 * This method controls the `public` or `private` directive in the Cache-Control
	 * header
	 *
	 * @param boolean $public  if set to true, the Cache-Control header will be set as public
	 * if set to false, the response will be set to private
	 * @param int $time time in seconds after which the response should no longer be considered fresh
	 * @return \Core\Request $this
	 */
	public function setSharable($public = true, $time = null)
	{
		if ($public)
		{
			$this->_cacheDirectives['public'] = true;
			unset($this->_cacheDirectives['private']);
			$time and $this->setSharedMaxAge($time);
		}
		else
		{
			$this->_cacheDirectives['private'] = true;
			unset($this->_cacheDirectives['public']);
			$time and $this->setMaxAge($time);
		}

		return $this;
	}

	/**
	 * Return whether the response is sharable or not
	 * @return bool
	 */
	public function getSharable()
	{
		$public = array_key_exists('public', $this->_cacheDirectives);
		$private = array_key_exists('private', $this->_cacheDirectives);
		$noCache = array_key_exists('no-cache', $this->_cacheDirectives);

		if (!$public and !$private and !$noCache)
			return null;

		$sharable = $public || ! ($private || $noCache);
		return $sharable;
	}

	/**
	 * Sets the Cache-Control s-maxage directive.
	 * The max-age is the number of seconds after which the response should no longer be considered
	 * a good candidate to be fetched from a shared cache (like in a proxy server).
	 *
	 * @param int $seconds if null, the method will return the current s-maxage value
	 * @return \Core\Request $this
	 */
	public function setSharedMaxAge($seconds = null)
	{
		$this->_cacheDirectives['s-maxage'] = $seconds;
		return $this;
	}

	/**
	 * Return the current max-age value if any
	 *
	 * @return int|null
	 */
	public function getSharedMaxAge()
	{
		if (isset($this->_cacheDirectives['s-maxage']))
			return $this->_cacheDirectives['s-maxage'];

		return null;
	}

	/**
	 * Sets the Cache-Control max-age directive.
	 * The max-age is the number of seconds after which the response should no longer be considered
	 * a good candidate to be fetched from the local (client) cache.
	 *
	 * @param int $seconds
	 * @return \Core\Request $this
	 */
	public function setMaxAge($seconds = null)
	{
		if ($seconds !== null)
			$this->_cacheDirectives['max-age'] = $seconds;

		return $this;
	}

	/**
	 * Return the current max-age value if any
	 *
	 * @return int|null
	 */
	public function getMaxAge()
	{
		if (isset($this->_cacheDirectives['max-age']))
			return $this->_cacheDirectives['max-age'];

		return null;
	}

	/**
	 * Sets the Cache-Control must-revalidate directive.
	 * must-revalidate indicates that the response should not be served
	 * stale by a cache under any cirumstance without first revalidating
	 * with the origin.
	 *
	 * @param bool $enable must-revalidate value
	 * @return \Core\Request $this
	 */
	public function setMustRevalidate($enable = true)
	{
		if ($enable)
			$this->_cacheDirectives['must-revalidate'] = true;
		else
			unset($this->_cacheDirectives['must-revalidate']);

		return $this;
	}

	/**
	 * Return wheter must-revalidate is present
	 * @return bool
	 */
	public function getMustRevalidate()
	{
		return array_key_exists('must-revalidate', $this->_cacheDirectives);
	}


	/**
	 * Sets the Expires header for the response by taking an expiration time
	 *
	 * ## Examples:
	 *
	 * `$response->expires('now')` Will Expire the response cache now
	 * `$response->expires(new DateTime('+1 day'))` Will set the expiration in next 24 hours
	 *
	 * @param string|int $time Date format recognizable by strtotime or timestamp
	 * @return \Core\Request $this
	 */
	public function setExpires($time = null)
	{
		$this->_headers['Expires'] = gmdate('D, j M Y H:i:s', is_int($time) ? $time : strtotime($time)) . ' GMT';
		return $this;
	}

	/**
	 * Return the current Expires value
	 *
	 * @return string
	 */
	public function getExpires()
	{
		if (isset($this->_headers['Expires']))
			return $this->_headers['Expires'];

			return null;
	}

	/**
	 * Sets the Last-Modified header for the response by taking an modification time
	 *
	 * ## Examples:
	 *
	 * `$response->modified('now')` Will set the Last-Modified to the current time
	 * `$response->modified(new DateTime('+1 day'))` Will set the modification date in the past 24 hours
	 *
	 * @param string|int $time Date format recognizable by strtotime or timestamp
	 * @return \Core\Request $this
	 */
	public function setLastModified($time)
	{
		$this->_headers['Last-Modified'] = gmdate('D, j M Y H:i:s', is_int($time) ? $time : strtotime($time)) . ' GMT';
		return $this;
	}

	/**
	 * Return the current Last-Modified value
	 *
	 * @return string
	 */
	public function getLastModified()
	{
		if (isset($this->_headers['Last-Modified']))
			return $this->_headers['Last-Modified'];

		return null;
	}

	/**
	 * Sets the correct headers to instruct the client NOT to cache the response.
	 */
	public function disableCache()
	{
		$this->_headers['Expires'] = 'Mon, 26 Jul 1997 05:00:00 GMT';
		$this->_headers['Last-Modified'] = gmdate("D, d M Y H:i:s") . " GMT";
		$this->_headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, post-check=0, pre-check=0';
	}

	/**
	 * Set the current status code
	 *
	 * @param int $status
	 * @return \Core\Request $this
	 */
	public function setStatus($status = 200)
	{
		$this->status = $status;
		return $this;
	}

	/**
	 * Return the current status code
	 *
	 * @return int
	 */
	public function getStatus()
	{
		return $this->status;
	}

	/**
	 * Sets a header
	 *
	 * @param string $name Name
	 * @param string $value Value
	 * @param bool $replace Replace a existing one?
	 * @return \Core\Request $this
	 */
	public function setHeader($name, $value, $replace = true)
	{
		if ($replace)
		{
			$this->_headers[$name] = $value;
		}
		else
		{
			$this->_headers[] = [$name, $value];
		}

		return $this;
	}

	/**
	 * Get a header of current response
	 *
	 * @param string $name Name or null to get all inside an array
	 * @return string|array
	 */
	public function getHeader($name = null)
	{
		if ($name)
		{
			return isset($this->_headers[$name]) ? $this->_headers[$name] : null;
		}
		else
		{
			return $this->_headers;
		}
	}

	/**
	 * Set the content to be sent to client
	 *
	 * @param string
	 * @return \Core\Request $this
	 */
	public function setBody($value)
	{
		$this->body = $value;
		return $this;
	}

	/**
	 * Get the current content to be sent to client
	 *
	 * @return string
	 */
	public function getBody()
	{
		return $this->body;
	}

	/**
	 * If casted to string, get the current body
	 *
	 * @return string
	 */
	public function __toString() {
		return $this->getBody();
	}

	/**
	 * Send all headers of the request
	 *
	 * @return bool
	 * @throws RequestException
	 */
	protected function _sendHeaders()
	{
		if ( ! headers_sent($file, $line))
		{
			// Trigger the events before send headers
			Event::trigger('before_send_headers');

			// Send the cookies
			foreach ($this->_cookies as $cookie)
			{
				setcookie(
					$cookie['name'], $cookie['value'], $cookie['expire'], $cookie['path'],
					$cookie['domain'], $cookie['secure'], $cookie['http_only']
				);
			}

			// Send the response code
			http_response_code($this->status);

			// Set the content-header and charset
			if ( ! in_array($this->status, [304, 204]))
			{
				$content_type = Config::get('mimes.' . $this->contentType, $this->contentType);
				if (strpos($content_type, 'text/') === 0) {
					$this->_headers['Content-Type'] = $content_type . '; charset=' . $this->charset;
				} else {
					$this->_headers['Content-Type'] = $content_type;
				}
			}

			// Send the cache-control directives
			$control = '';
			foreach ($this->_cacheDirectives as $key => $val) {
				$control .= $val === true ? $key : sprintf('%s=%s', $key, $val);
				$control .= ', ';
			}
			$control = rtrim($control, ', ');
			$this->_headers['Cache-Control'] = $control;

			// Send the headers
			foreach ($this->_headers as $name => $value)
			{
				// Parse non-replace headers
				is_int($name) and is_array($value) and list($name, $value) = $value;

				// Create the header
				is_string($name) and $value = "{$name}: {$value}";

				// Send it
				header($value, true);
			}
			return true;
		}

		throw new RequestException('Headers already sent in file ' . $file . ' @ line: ' . $line);
	}

	/**
	 * Send the output html to the client
	 */
	protected function _sendBody()
	{
		Event::trigger('before_send_body');
		echo $this->body;
	}

	/**
	 * Send all the content to the browser
	 *
	 * @param bool $body Whether to send the body output or not
	 */
	public function send($body = true)
	{
		// Disallow any kind of echo'es outside the Request body
		do {
			ob_get_clean();
		} while (ob_get_level());

		$this->_sendHeaders();
		$body === true and $this->_sendBody();
	}
}
// End of file: <Core\Request.php>

// File: <Core\Router.php>
namespace Core;

class Router
{
	/**
	 * Translate a URL into a route, or use the current inputted if none given
	 *
	 * @param type $url
	 * @param string $method [GET, POST, PUT, DELETE, ALL]
	 * @param string $domain
	 * @return \Core\Route
	 * @throws \Core\HttpNotFoundException
	 */
	public static function resolve($url = null, $method = null, $domain = null)
	{
		\Core\Profiler::markStart(__METHOD__);

		// If none given, detect manually
		if ($url === null)
		{
			$url = \Core\URL::getRequestString();
		}

		// Trim the URL slashes
		$url = trim($url, '/');

		// If none given, detect manually
		if ($domain === null)
		{
			$domain = \Core\Input::server('HTTP_HOST');
		}

		// If none given, detect manually
		if($method === null)
		{
			$method = \Core\Input::method();
		}

		// First we try to search all routes specified
		foreach(\Core\Config::get('routes') as $route)
		{
			if($route->match($url, $method, $domain))
			{
				\Core\Profiler::markEnd(__METHOD__);
				return $route;
			}
		}

		// Lets use the normal router system then
		$config = \Core\Config::get('system.router');

		if ($config['dynamic_mode'])
		{
			$url = \Core\URL::translate($url);

			$controller = ( ! empty($url['module']) ? '\\Module\\' . $url['module'] . '\\' : '') . 'Controller\\' . $url['controller'];
			$filename = APPPATH . 'Lib' . DS . APPNAME . ( ! empty($url['module']) ? DS . 'Module' . DS . $url['module'] : '') . DS . 'Controller' . DS . $url['controller'] . '.php';
			$action = $url['action'];

			if(is_file($filename) and method_exists(APPNAME . '\\' . $controller, $action . 'Action'))
			{
				\Core\Profiler::markEnd(__METHOD__);
				return \Core\Route::make($controller, $action)->setParams($url['arguments']);
			}
		}

		\Core\Profiler::markEnd(__METHOD__);
		throw new \Core\HttpNotFoundException('No matching route found!');
	}
}
// End of file: <Core\Router.php>

// File: <Core\URL.php>
namespace Core;

class URL
{
	/**
	 * Gets the base URL of the system without the trailing slash.
	 *
	 * E.g: '/baseurl' or '' if the base is in root
	 *
	 * @return string
	 */
	public static function getBase()
	{
		return rtrim('/' . trim(Config::get('system.base_url'), '/'), '/');
	}

	/**
	 * Creates a url with the given uri, including the base url
	 *
	 * @param string $uri The uri to create the URL for
	 * @param array|string $get_variables Any GET urls to append via a query string
	 * @param bool $secure If false, force http. If true, force https
	 * @return string
	 */
	public static function create($uri = null, $get_variables = array(), $secure = null)
	{
		$url = '';

		// If the given uri is not a full URL
		if( ! preg_match("#^(http|https|ftp)://#i", $uri))
		{
			$url .= static::base();
		}

		$uri and $url .= '/' . trim($uri, '/');

		if ( ! empty($get_variables))
		{
			$char = strpos($url, '?') === false ? '?' : '&';

			if (is_string($get_variables))
			{
				$url .= $char . str_replace('%3A', ':', $get_variables);
			}
			else
			{
				$url .= $char . str_replace('%3A', ':', http_build_query($get_variables, null, '&'));
			}
		}

		is_bool($secure) and $url = http_build_url($url, array('scheme' => $secure ? 'https' : 'http'));

		return $url;
	}

	/**
	 * Detects and returns the current URL without the trailing slash
	 *
	 * @return string
	 */
	public static function getFull()
	{
		static $url = null;
		if($url === null)
		{
			$url = Input::protocol() . '://' . strtolower($_SERVER['SERVER_NAME']) . rtrim($_SERVER['REQUEST_URI'], '/');
		}

		return $url;
	}

	/**
	 * Gets the request string without the trailing slashes
	 *
	 * @return string
	 */
	public static function getRequestString()
	{
		static $request_string = null;
		if($request_string === null)
		{
			// If is there a PATH_INFO var, we use it and take off the trailing slashes
			if (isset($_SERVER['PATH_INFO']))
			{
				$url = trim(parse_url($_SERVER['PATH_INFO'], PHP_URL_PATH), '/');
			}
			// Otherwise, we try to emulate the PATH_INFO, cleaning all the double-slashes from the REQUEST_URI
			else
			{
				$url = parse_url(preg_replace('#/+#i', '/', trim(Input::server('REQUEST_URI'), '/ ')), PHP_URL_PATH);
			}

			$request_string = trim((string) substr($url, strlen(trim(Config::get('system.base_url'), '/'))), '/');
		}

		// Then we slice the string from the base_url setting, removing all the trailing slashes
		return $request_string;
	}

	/**
	 * Get the segment of URL
	 *
	 * @param int $segment
	 * @return string
	 */
	public static function getSegment($segment = null)
	{
		$segments = explode('/', static::getRequestString());

		if (empty($segments))
		{
			return '';
		}

		return isset($segments[(int)$segment]) ? $segments[(int)$segment] : '';
	}

	/**
	 * Detects the extension inputted in URL
	 *
	 * @staticvar string $ext
	 * @return string
	 */
	public static function getExtension()
	{
		static $ext = null;

		if ($ext === null)
		{
			$ext = pathinfo(static::getRequestString(), PATHINFO_EXTENSION);
		}

		return $ext;
	}

	/**
	 * Translate a URL in module/controller/action/args format.
	 * If you are using the modules system, this will check if the module exist,
	 * and if it doesn't, the default module will be used instead
	 *
	 * @param string $url
	 * @return array
	 */
	public static function translate($url)
	{
		if(empty($url))
		{
			$url = 'index/index';
		}

		$parts = (array) explode('/', $url);

		if(Config::get('system.router.use_modules'))
		{
			$module = ! empty($parts[0]) ? static::nameToModule($parts[0]) : static::nameToModule(Config::get('system.router.default_module'));
			if ( ! is_dir(APPPATH . 'classes' . DS . APPNAME . DS . 'Module' . DS . ucfirst($module)))
			{
				$module = static::nameToModule(Config::get('system.router.default_module'));
				array_unshift($parts, null);
			}
		}
		else
		{
			$module = null;
			array_unshift($parts, null);
		}

		return array(
			'module' => $module,
			'controller' => ! empty($parts[1]) ? static::nameToController($parts[1]) : 'Index',
			'action' => ! empty($parts[2]) ? static::nameToAction($parts[2]) : 'index',
			'arguments' => array_slice($parts, 3),
		);
	}

	/**
	 * Use the Coffee conventions to convert a URL segment into a module name
	 *
	 * @param string $string
	 * @return string
	 */
	public static function nameToModule($string)
	{
		return \Core\Inflector::dashesToStudlyCase($string);
	}

	/**
	 * Use the Coffee conventions to convert a URL segment into a controller name
	 *
	 * @param string $string
	 * @return string
	 */
	public static function nameToController($string)
	{
		return static::nameToModule($string);
	}

	/**
	 * Use the Coffee conventions to convert a URL segment into a action name
	 *
	 * @param string $string
	 * @return string
	 */
	public static function nameToAction($string)
	{
		return \Core\Inflector::dashesToCamelCase($string);
	}
}
// End of file: <Core\URL.php>

// File: <Core\Input.php>
namespace Core;

/**
 * Input class
 *
 * The input class allows you to access HTTP parameters, load server variables
 * and user agent details.
 *
 * @package   Fuel
 * @category  Core
 * @link      http://docs.fuelphp.com/classes/input.html
 */

class Input
{
	/**
	 * All of the input (GET, POST, PUT, DELETE)
	 * @var array
	 */
	protected static $_input = null;

	/**
	 * All of the put or delete vars
	 * @var array
	 */
	protected static $_putDeleteVars = null;

	/**
	 * Get the public ip address of the user.
	 *
	 * @param string Default value in case the detection fails
	 * @return string
	 */
	public static function ip($default = '0.0.0.0')
	{
		if (static::server('REMOTE_ADDR') !== null)
		{
			return static::server('REMOTE_ADDR');
		}
		else
		{
			// detection failed, return the default
			return $default;
		}
	}

	/**
	 * Return's the protocol that the request was made with
	 *
	 * @return string
	 */
	public static function protocol()
	{
		if ((static::server('HTTPS') !== null and static::server('HTTPS') != 'off')
			or (static::server('HTTPS') === null and static::server('SERVER_PORT') == 443))
		{
			return 'https';
		}

		return 'http';
	}

	/**
	 * Return's whether this is an AJAX request or not
	 *
	 * @return bool
	 */
	public static function isAjax()
	{
		return (static::server('HTTP_X_REQUESTED_WITH') !== null) and strtolower(static::server('HTTP_X_REQUESTED_WITH')) === 'xmlhttprequest';
	}

	/**
	 * Return's the referrer
	 *
	 * @param string Default value in case the detection fails
	 * @return string
	 */
	public static function referrer($default = '')
	{
		return static::server('HTTP_REFERER', $default);
	}

	/**
	 * Return's the input method used (GET, POST, DELETE, etc.)
	 *
	 * @param string Default value in case the detection fails
	 * @return string
	 */
	public static function method($default = 'GET')
	{
		return static::server('HTTP_X_HTTP_METHOD_OVERRIDE', static::server('REQUEST_METHOD', $default));
	}

	/**
	 * Return's the user agent
	 *
	 * @param string Default value in case the detection fails
	 * @return string
	 */
	public static function userAgent($default = '')
	{
		return static::server('HTTP_USER_AGENT', $default);
	}

	/**
	 * Returns all of the GET, POST, PUT and DELETE variables.
	 *
	 * @return array
	 */
	public static function all()
	{
		if (is_null(static::$_input))
		{
			static::_hydrate();
		}

		return static::$_input;
	}

	/**
	 * Gets the specified GET variable.
	 *
	 * @param string $index The index to get or null to get all
	 * @param string $default The default value
	 * @return string|array
	 */
	public static function get($index = null, $default = null)
	{
		return (is_null($index) and func_num_args() === 0) ? $_GET : Arr::get($_GET, $index, $default);
	}

	/**
	 * Fetch an item from the POST array
	 *
	 * @param string  The index key or null to get all
	 * @param mixed   The default value
	 * @return string|array
	 */
	public static function post($index = null, $default = null)
	{
		return (is_null($index) and func_num_args() === 0) ? $_POST : Arr::get($_POST, $index, $default);
	}

	/**
	 * Fetch an item from the php://input for put arguments
	 *
	 * @param string The index key or null to get all
	 * @param mixed The default value
	 * @return string|array
	 */
	public static function put($index = null, $default = null)
	{
		if (is_null(static::$_putDeleteVars))
		{
			static::_hydrate();
		}

		return (is_null($index) and func_num_args() === 0) ? static::$_putDeleteVars : Arr::get(static::$_putDeleteVars, $index, $default);
	}

	/**
	 * Fetch an item from the php://input for delete arguments
	 *
	 * @param string The index key or null to get all
	 * @param mixed The default value
	 * @return string|array
	 */
	public static function delete($index = null, $default = null)
	{
		if (is_null(static::$_putDeleteVars))
		{
			static::_hydrate();
		}

		return (is_null($index) and func_num_args() === 0) ? static::$_putDeleteVars : Arr::get(static::$_putDeleteVars, $index, $default);
	}

	/**
	 * Fetch an item from the FILE array
	 *
	 * @param string The index key or null to get all
	 * @param mixed The default value
	 * @return string|array
	 */
	public static function file($index = null, $default = null)
	{
		return (is_null($index) and func_num_args() === 0) ? $_FILES : Arr::get($_FILES, $index, $default);
	}

	/**
	 * Fetch an item from either the GET, POST, PUT or DELETE array
	 *
	 * @param string The index key or null to get all
	 * @param mixed The default value
	 * @return string|array
	 */
	public static function param($index = null, $default = null)
	{
		if (is_null(static::$_input))
		{
			static::_hydrate();
		}

		return Arr::get(static::$_input, $index, $default);
	}

	/**
	 * Fetch an item from the COOKIE array
	 *
	 * @param string The index key or null to get all
	 * @param mixed The default value
	 * @return string|array
	 */
	public static function cookie($index = null, $default = null)
	{
		return (is_null($index) and func_num_args() === 0) ? $_COOKIE : Arr::get($_COOKIE, $index, $default);
	}

	/**
	 * Fetch an item from the SERVER array
	 *
	 * @param string The index key or null to get all
	 * @param mixed The default value
	 * @return string|array
	 */
	public static function server($index = null, $default = null)
	{
		return (is_null($index) and func_num_args() === 0) ? $_SERVER : Arr::get($_SERVER, strtoupper($index), $default);
	}

	/**
	 * Hydrates the input array
	 */
	protected static function _hydrate()
	{
		static::$_input = array_merge($_GET, $_POST);

		if (static::method() == 'PUT' or static::method() == 'DELETE')
		{
			parse_str(file_get_contents('php://input'), static::$_putDeleteVars);
			static::$_input = array_merge(static::$_input, static::$_putDeleteVars);
		}
	}
}
// End of file: <Core\Input.php>

// File: <Core\Arr.php>
namespace Core;

/**
 * The Arr class provides a few nice functions for making
 * dealing with arrays easier
 *
 * @package     Fuel
 * @subpackage  Core
 */
class Arr
{

	/**
	 * Gets a dot-notated key from an array, with a default value if it does
	 * not exist.
	 *
	 * @param array $array The search array
	 * @param mixed $key The dot-notated key or array of keys
	 * @param string $default The default value
	 * @return mixed
	 */
	public static function get($array, $key, $default = null)
	{
		if ( ! is_array($array) and ! $array instanceof \ArrayAccess)
		{
			throw new \InvalidArgumentException('First parameter must be an array or ArrayAccess object.');
		}

		if (is_null($key))
		{
			return $array;
		}

		if (is_array($key))
		{
			$return = array();
			foreach ($key as $k)
			{
				$return[$k] = static::get($array, $k, $default);
			}
			return $return;
		}

		foreach (explode('.', $key) as $key_part)
		{
			if (($array instanceof \ArrayAccess and isset($array[$key_part])) === false)
			{
				if ( ! is_array($array) or ! array_key_exists($key_part, $array))
				{
					return value($default);
				}
			}

			$array = $array[$key_part];
		}

		return $array;
	}

	/**
	 * Set an array item (dot-notated) to the value.
	 *
	 * @param array $array The array to insert it into
	 * @param mixed $key The dot-notated key to set or array of keys
	 * @param mixed $value The value
	 */
	public static function set(&$array, $key, $value = null)
	{
		if (is_null($key))
		{
			$array = $value;
			return;
		}

		if (is_array($key))
		{
			foreach ($key as $k => $v)
			{
				static::set($array, $k, $v);
			}
		}

		$keys = explode('.', $key);

		while (count($keys) > 1)
		{
			$key = array_shift($keys);

			if ( ! isset($array[$key]) or ! is_array($array[$key]))
			{
				$array[$key] = array();
			}

			$array =& $array[$key];
		}

		$array[array_shift($keys)] = $value;
	}

	/**
	 * Array_key_exists with a dot-notated key from an array.
	 *
	 * @param array $array The search array
	 * @param mixed $key The dot-notated key or array of keys
	 * @return bool
	 */
	public static function keyExists($array, $key)
	{
		foreach (explode('.', $key) as $key_part)
		{
			if ( ! is_array($array) or ! array_key_exists($key_part, $array))
			{
				return false;
			}

			$array = $array[$key_part];
		}

		return true;
	}

	/**
	 * Unsets dot-notated key from an array
	 *
	 * @param array $array The search array
	 * @param mixed $key The dot-notated key or array of keys
	 * @return bool
	 */
	public static function delete(&$array, $key)
	{
		if (is_null($key))
		{
			return false;
		}

		if (is_array($key))
		{
			$return = array();
			foreach ($key as $k)
			{
				$return[$k] = static::delete($array, $k);
			}
			return $return;
		}

		$key_parts = explode('.', $key);

		if ( ! is_array($array) or ! array_key_exists($key_parts[0], $array))
		{
			return false;
		}

		$this_key = array_shift($key_parts);

		if ( ! empty($key_parts))
		{
			$key = implode('.', $key_parts);
			return static::delete($array[$this_key], $key);
		}
		else
		{
			unset($array[$this_key]);
		}

		return true;
	}

	/**
	 * Converts a multi-dimensional associative array into an array of key => values with the provided field names
	 *
	 * @param array The array to convert
	 * @param string The field name of the key field
	 * @param string The field name of the value field
	 * @return array
	 */
	public static function assocToKeyval($assoc = null, $key_field = null, $val_field = null)
	{
		if(empty($assoc) or empty($key_field) or empty($val_field))
		{
			return null;
		}

		$output = array();
		foreach($assoc as $row)
		{
			if(isset($row[$key_field]) AND isset($row[$val_field]))
			{
				$output[$row[$key_field]] = $row[$val_field];
			}
		}

		return $output;
	}

	/**
	 * Converts the given 1 dimensional non-associative array to an associative
	 * array.
	 *
	 * The array given must have an even number of elements or null will be returned.
	 *
	 *     Arr::to_assoc(array('foo','bar'));
	 *
	 * @param string $arr The array to change
	 * @return array|null The new array or null
	 */
	public static function toAssoc($arr)
	{
		if (($count = count($arr)) % 2 > 0)
		{
			return null;
		}
		$keys = $vals = array();

		for ($i = 0; $i < $count - 1; $i += 2)
		{
			$keys[] = array_shift($arr);
			$vals[] = array_shift($arr);
		}
		return array_combine($keys, $vals);
	}

	/**
	 * Checks if the given array is an assoc array.
	 *
	 * @param array $arr The array to check
	 * @return bool
	 */
	public static function isAssoc($arr)
	{
		foreach ($arr as $key => $unused)
		{
			if ( ! is_int($key))
			{
				return true;
			}
		}
		return false;
	}

	/**
	 * Flattens a multi-dimensional associative array down into a 1 dimensional
	 * associative array.
	 *
	 * @param array The array to flatten
	 * @param string What to glue the keys together with
	 * @param bool Whether to reset and start over on a new array
	 * @param bool Whether to flatten only associative array's, or also indexed ones
	 * @return array
	 */
	public static function flatten($array, $glue = ':', $reset = true, $indexed = true)
	{
		static $return = array();
		static $curr_key = array();

		if ($reset)
		{
			$return = array();
			$curr_key = array();
		}

		foreach ($array as $key => $val)
		{
			$curr_key[] = $key;
			if (is_array($val) and ($indexed or array_values($val) !== $val))
			{
				static::flatten($val, $glue, false, $indexed);
			}
			else
			{
				$return[implode($glue, $curr_key)] = $val;
			}
			array_pop($curr_key);
		}
		return $return;
	}

	/**
	 * Flattens a multi-dimensional associative array down into a 1 dimensional
	 * associative array.
	 *
	 * @param array The array to flatten
	 * @param string What to glue the keys together with
	 * @param bool Whether to reset and start over on a new array
	 * @return array
	 */
	public static function flattenAssoc($array, $glue = ':', $reset = true)
	{
		return static::flatten($array, $glue, $reset, false);
	}

	/**
	 * Filters an array on prefixed associative keys.
	 *
	 * @param array The array to filter.
	 * @param string Prefix to filter on.
	 * @param bool Whether to remove the prefix.
	 * @return array
	 */
	public static function filterPrefixed($array, $prefix = 'prefix_', $remove_prefix = true)
	{
		$return = array();
		foreach ($array as $key => $val)
		{
			if(preg_match('/^'.$prefix.'/', $key))
			{
				if($remove_prefix === true)
				{
					$key = preg_replace('/^'.$prefix.'/','',$key);
				}
				$return[$key] = $val;
			}
		}
		return $return;
	}

	/**
	 * Filters an array by an array of keys
	 *
	 * @param array The array to filter.
	 * @param array The keys to filter
	 * @param bool If true, removes the matched elements.
	 * @return array
	 */
	public static function filterKeys(array $array, $keys, $remove = false)
	{
		$return = array();
		foreach ($keys as $key)
		{
			if (isset($array[$key]))
			{
				$remove or $return[$key] = $array[$key];
				if($remove)
				{
					unset($array[$key]);
				}
			}
		}
		return $remove ? $array : $return;
	}

	/**
	 * Insert value(s) into an array, mostly an array_splice alias
	 * WARNING: original array is edited by reference, only boolean success is returned
	 *
	 * @param array The original array (by reference)
	 * @param array|mixed The value(s) to insert, if you want to insert an array it needs to be in an array itself
	 * @param int The numeric position at which to insert, negative to count from the end backwards
	 * @return bool False when array shorter then $pos, otherwise true
	 */
	public static function insert(array &$original, $value, $pos)
	{
		if (count($original) < abs($pos))
		{
			trigger_error('Position larger than number of elements in array in which to insert.');
			return false;
		}

		array_splice($original, $pos, 0, $value);
		return true;
	}

	/**
	 * Insert value(s) into an array before a specific key
	 * WARNING: original array is edited by reference, only boolean success is returned
	 *
	 * @param array The original array (by reference)
	 * @param array|mixed The value(s) to insert, if you want to insert an array it needs to be in an array itself
	 * @param string|int The key before which to insert
	 * @return bool False when key isn't found in the array, otherwise true
	 */
	public static function insertBeforeKey(array &$original, $value, $key)
	{
		$pos = array_search($key, array_keys($original));
		if ($pos === false)
		{
			trigger_error('Unknown key before which to insert the new value into the array.');
			return false;
		}

		return static::insert($original, $value, $pos);
	}

	/**
	 * Insert value(s) into an array after a specific key
	 * WARNING: original array is edited by reference, only boolean success is returned
	 *
	 * @param array The original array (by reference)
	 * @param array|mixed The value(s) to insert, if you want to insert an array it needs to be in an array itself
	 * @param string|int The key after which to insert
	 * @return bool False when key isn't found in the array, otherwise true
	 */
	public static function insertAfterKey(array &$original, $value, $key)
	{
		$pos = array_search($key, array_keys($original));
		if ($pos === false)
		{
			trigger_error('Unknown key after which to insert the new value into the array.');
			return false;
		}

		return static::insert($original, $value, $pos + 1);
	}

	/**
	 * Insert value(s) into an array after a specific value (first found in array)
	 *
	 * @param array The original array (by reference)
	 * @param array|mixed The value(s) to insert, if you want to insert an array it needs to be in an array itself
	 * @param string|int The value after which to insert
	 * @return bool False when value isn't found in the array, otherwise true
	 */
	public static function insertAfterValue(array &$original, $value, $search)
	{
		$key = array_search($search, $original);
		if ($key === false)
		{
			trigger_error('Unknown value after which to insert the new value into the array.');
			return false;
		}

		return static::insert_after_key($original, $value, $key);
	}

	/**
	 * Sorts a multi-dimensional array by it's values.
	 *
	 * @param array The array to fetch from
	 * @param string The key to sort by
	 * @param string The order (asc or desc)
	 * @param int The php sort type flag
	 * @return array
	 * @throws \InvalidArgumentException
	 */
	public static function sort(array $array, $key, $order = 'asc', $sort_flags = SORT_REGULAR)
	{
		foreach ($array as $k => $v)
		{
			$b[$k] = static::get($v, $key);
		}

		switch ($order)
		{
			case 'asc':
				asort($b, $sort_flags);
			break;

			case 'desc':
				arsort($b, $sort_flags);
			break;

			default:
				throw new \InvalidArgumentException('Arr::sort() - $order must be asc or desc.');
			break;
		}

		foreach ($b as $key => $val)
		{
			$c[] = $array[$key];
		}

		return $c;
	}

	/**
	 * Find the average of an array
	 *
	 * @param array The array containing the values
	 * @return int The average value
	 */
	public static function average(array $array)
	{
		// No arguments passed, lets not divide by 0
		if ( ! ($count = count($array)) > 0)
			return 0;

		return (array_sum($array) / $count);
	}

	/**
	 * Replaces key names in an array by names in $replace
	 *
	 * @param array The array containing the key/value combinations
	 * @param array|string Key to replace or array containing the replacement keys
	 * @param string The replacement key
	 * @return array The array with the new keys
	 * @throws \InvalidArgumentException
	 */
	public static function replaceKey(array $source, $replace, $new_key = null)
	{
		if(is_string($replace))
			$replace = array($replace => $new_key);

		if ( ! is_array($source) or ! is_array($replace))
			throw new \InvalidArgumentException('Arr::replace_keys() - $source must an array. $replace must be an array or string.');

		$result = array();

		foreach ($source as $key => $value)
		{
			if (array_key_exists($key, $replace))
				$result[$replace[$key]] = $value;
			else
				$result[$key] = $value;
		}

		return $result;
	}

	/**
	 * Merge 2 arrays recursively, differs in 2 important ways from array_merge_recursive()
	 * - When there's 2 different values and not both arrays, the latter value overwrites the earlier
	 *   instead of merging both into an array
	 * - Numeric keys that don't conflict aren't changed, only when a numeric key already exists is the
	 *   value added using array_push()
	 *
	 * @param array Multiple variables all of which must be arrays
	 * @return array
	 * @throws \InvalidArgumentException
	 */
	public static function merge()
	{
		$array  = func_get_arg(0);
		$arrays = array_slice(func_get_args(), 1);

		if ( ! is_array($array))
		{
			throw new \InvalidArgumentException('Arr::merge() - all arguments must be arrays.');
		}

		foreach ($arrays as $arr)
		{
			if(empty($arr))
				continue;

			if ( ! is_array($arr))
				throw new \InvalidArgumentException('Arr::merge() - all arguments must be arrays.');

			foreach ($arr as $k => $v)
			{
				// numeric keys are appended
				if (is_int($k))
					array_key_exists($k, $array) ? array_push($array, $v) : $array[$k] = $v;
				elseif (is_array($v) and array_key_exists($k, $array) and is_array($array[$k]))
					$array[$k] = static::merge($array[$k], $v);
				else
					$array[$k] = $v;
			}
		}

		return $array;
	}

	/**
	 * Prepends a value with an asociative key to an array.
	 * Will overwrite if the value exists.
	 *
	 * @param array $arr The array to prepend to
	 * @param string|array $key The key or array of keys and values
	 * @param mixed $value the Value to prepend
	 */
	public static function prepend(array &$arr, $key, $value = null)
	{
		$arr = (is_array($key) ? $key : array($key => $value)) + $arr;
	}
}
// End of file: <Core\Arr.php>

// File: <Core\Route.php>
namespace Core;

class Route
{
	/**
	 * Methods used by this route
	 * @var array
	 */
	public $methods = array();

	/**
	 * Regex pattern to reach this route
	 * @var string
	 */
	public $pattern = null;

	/**
	 * All the domains allowed to reach the route
	 * @var type
	 */
	public $domains = array();

	/**
	 * Controller name
	 * @var string
	 */
	public $controller = null;

	/**
	 * Action name
	 * @var string
	 */
	public $action = null;

	/**
	 * Params of the resolved route
	 * @var array
	 */
	public $params = array();

	/**
	 * Constructor
	 *
	 * @param string $controller
	 * @param string $action
	 * @param string $pattern Regex URL to reach the route
	 * @param array $methods [GET, POST, DELETE, PUT, ALL]
	 * @param array $domains The domains allowed the this route
	 */
	public function __construct($controller, $action, $pattern = null, array $methods = array('ALL'), array $domains = null)
	{
		if ( ! empty($methods))
		{
			foreach($methods as &$method)
			{
				$method = strtoupper($method);
			}
		}

		if ($pattern !== null)
		{
			// Faz um tratamento na pattern, permitindo atalhos fáceis
			$pattern = '#^' . str_replace(array(
				':any',
				':string',
				':num',
				':letters',
				':segment',
				'{/}',
			), array(
				'.+',
				'[[:alnum:]]+',
				'[[:digit:]]+',
				'[[:alpha:]]+',
				'[^/]+',
				'(?:/)',
			), $pattern) . '$#iu';
		}


		if( ! empty($domains))
		{
			// Do a glob inside the domain pattern
			foreach ($domains as &$domain)
			{
				$domain = '#^' . strtr(preg_quote($domain, '#'), array(
					'*' => '[^.]*',
					'.' => '\\.',
				)) . '#iu';
			}
		}

		// Set the internal vars
		$this->controller = APPNAME . '\\' . $controller;
		$this->methods = $methods;
		$this->pattern = $pattern;
		$this->action = $action;
		$this->domains = $domains;
	}

	/**
	 * Constructor with factory pattern
	 *
	 * @param string $controller
	 * @param string $action
	 * @param string $pattern Regex URL to reach the route
	 * @param array $methods [GET, POST, DELETE, PUT, ALL]
	 * @param array $domains The domains allowed the this route
	 */
	public static function make($controller, $action, $pattern = null, array $methods = array('ALL'), array $domains = null)
	{
		return new static($controller, $action, $pattern, $methods, $domains);
	}

	/**
	 * Check if the route matches with the URL and Method given
	 *
	 * @param type $url
	 * @param string $method [GET, POST, PUT, DELETE, ALL]
	 * @param string $domain
	 * @return \Core\Route|bool False if don't match
	 */
	public function match($url, $method = 'ALL', $domain = null)
	{
		if (
				(in_array('ALL', $this->methods) or in_array($method, $this->methods))
				and ($domain === null or empty($this->domains) or ($domain !== null and ! empty($this->domains) and $this->_matchDomain($domain)))
				and ! empty($this->pattern) and preg_match($this->pattern, $url, $matches)
		)
		{
			array_shift($matches);
			$this->params = $matches;
			return $this;
		}

		return false;
	}

	/**
	 * Match a domain a domain against the route domain list
	 *
	 * @param string $input
	 * @return bool
	 */
	protected function _matchDomain($input)
	{
		foreach ($this->domains as $domain)
		{
			if (preg_match($domain, $input))
			{
				return true;
			}
		}

		return false;
	}

	/**
	 * Set the route params
	 *
	 * @param array $params
	 * @return \Core\Route
	 */
	public function setParams(array $params)
	{
		$this->params = $params;
		return $this;
	}

	/**
	 * Return the param from resolved route, or get all if none given
	 *
	 * @param int $param
	 * @return string|array
	 */
	public function getParam($param = null)
	{
		if ($param === null or ! isset($this->params[$param]))
			return $this->params;

		return $this->params[$param];
	}
}
// End of file: <Core\Route.php>

// File: <Core\Controller\Basic.php>
namespace Core\Controller;

abstract class Basic
{
	/**
	 * The current request-response object
	 * @var \Core\Request
	 */
	public $request = null;
	
	/**
	 * The params used in URL
	 * @var array 
	 */
	public $params = array();

	/**
	 * Constructor (used by dispatcher)
	 * 
	 * @param \Core\Request $request
	 * @param array $params
	 */
	public function __construct(\Core\Request $request, array $params = array())
	{
		$this->request = $request;
		$this->params = $params;
	}

	/**
	 * Method called before every action
	 * Don't confuse with _init()
	 * 
	 * - The _init() method is called once this class is loaded
	 * no matter if it will be instantied, so it's static
	 * 
	 * - The before() method is before the dispatcher call the
	 * action, and if it return false, then the action won't be
	 * executed, and the dispatcher will stop. Useful for ACL stuff.
	 * 
	 * @param string $actionName
	 * @return void|bool False to stop the dispatch
	 */
	// public function before($actionName = null) {}

	/**
	 * Called after every request in controller. It must return the
	 * body string OR a \Core\Request object
	 * 
	 * @param string $response
	 * @param string $actionName
	 * @return string 
	 */
	/*public function after($response = null, $actionName = null)
	{
		return $response;
	}*/
	
	/**
	 * Get the specified param, or all of them inside an array if null given
	 * 
	 * @param string $param
	 * @param mixed $default
	 * @return string|array 
	 */
	public function getParam($param = null, $default = null)
	{
		return $param === null ? $this->params : (isset($this->params[$param]) ? $this->params[$param] : $default);
	}

	/**
	 * Get the current Request object
	 * 
	 * @return \Core\Request
	 */
	public function getRequest()
	{
		return $this->request;
	}
}
// End of file: <Core\Controller\Basic.php>

// File: <App\Controller\Index.php>
namespace App\Controller;

use
Core\Arr, Core\Cache, Core\Config, Core\Cookie, Core\Crypter,
Core\DB, Core\Debug, Core\File, Core\Input, Core\Date,
Core\Profiler, Core\Redis, Core\Security, Core\Session,
Core\Str, Core\URL, Core\Asset, Core\Inflector, Core\Format,
Core\Num, Core\Lang;

class Index extends \Core\Controller\Basic
{

	//public $cacheEnabled = true;

	/**
	 * Action for the index page
	 *
	 * @param array $params
	 */
	public function indexAction(array $params = array())
	{
		//\Core\Debug::dump(Input::server('HTTP_HOST'));
		//Asset::css('bootstrap.min.css');
		//Asset::css('bootstrap-responsive.min.css');
		//Asset::js('jquery-1.7.1.min.js');
		//Asset::js('bootstrap.min.js');
		//$this->cache();
		//\Core\Debug::dump(Inflector::friendlyTitle('dashes-to-cá†®´`~amel-case'));
		//if(str)
		//$this->response->setCache('10 March 2012 13:00:00', '30 March 2012 13:00:00');
		//$lol = \Core\URL::getFull();
		//var_dump($lol);
		//return Str::convertEncoding(strftime('%A %B a mae sua'));

		//$this->view->tenso = 'A123 é á eae';
		//return 123;
		//$this->view->setGlobal('title', '<teste></teste>', false);
		//$this->layout->title = 'suck my dick';
		/*\Core\Debug::dump(DB::table('char')
				->where('name', '=', 'kriansa')
				->joinUsing('login', 'account_id')
				->get(array(
					'char.char_id',
					'login.email',
					)));*/
		//$query = DB::query('select * from login where userid = ?', array('kriansa_adm'));
		//\Core\Debug::dump($query->getRow());
		//\Core\Debug::dump($query->getAll());
		/*$table = DB::table('char AS c')
				->where('name', '<>', DB::expr('"teste"'))
				->where('name', '<>', 'teste')
				->where('name', '<>', null)
				->where('name', '<>', DB::expr('"teste"'))
				->where('name', 'not between', array(0,9))
				->where('name', '<>', 'm aconha s')
				->select('name AS nome do personagem', 'char_id AS id do personagem');
		\Core\Debug::dump($table->getRow(0));*/
		/*Profiler::markStart('oi');
		\Core\Debug::dump(Date::fromFormat('12/31/1s992', 'us')->toFormat('local'));
		Profiler::markEnd('oi');
		/*$this->layout->title = '>eae';
		$this->view->global->maconha = 123;
		//$this->view->dados = DB::table('char')->where('name', 'like', '%a%')->get();
		$this->view->logged = null;
		$this->view->chars = array();
		//$this->view->global->title = '<teste>Pênes</teste>';
		//$this->clearCache();
		/*$aid = $this->accountData();
		$this->view->logged = (bool) $aid;
		DB::table('usuarios', array('eae', 'eae'))->where(array(
			'user_id' => 1
		));*/

		//Cache::getInstance('database')->garbageCollector();
		//\Core\Debug::dump(Cache::getInstance('database')->get('teste'));

		Cache::getInstance('session')->garbageCollector();
		//echo \Core\Num::bytesToHuman(2342423);
		//DB::getInstance('lol');
		Session::set('sexo', 666);
		//Session::set('access_token', 'iaheioaeheaio');
		//Session::set('sexo2', new Date);
		echo \Core\URL::getRequestString('sex');

		//\Core\Session::set('key', 'blablabla');
		//\Core\Session::regenerate();
		//echo \Core\Session::get('key');
	}

	public function personagensAction(array $params)
	{
		Asset::css('bootstrap.min.css');
		Asset::css('bootstrap-responsive.min.css');
		Asset::less('styles.less');
		Asset::js('jquery-1.7.2.min.js');
		Asset::js('bootstrap.min.js');

		$this->view->chars = DB::table('char as c')
			->select();
	}

	public function facebookLoginAction(array $params)
	{
		/*$provider = new \Core\Auth\OAuth2\Provider\Facebook(array(
			'id' => '160582154038100',
			'secret' => 'e3cdd48ec27c1b2441d5e82b3382af51',
			'redirect_uri' => 'http://127.0.0.2/index/facebook-login',
		));*/

		/**
		 * Se não enviou o code, significa que estamos enviando o usuário
		 * para o provider, para depois ele reenviar o usuário para esta
		 * página com o code, isso significa que a resposta veio
		 * Mas se já tivermos o token, não precisamos repetir o processo.
		 * OBS: Podemos salvar o token onde quiser-mos!!
		 */
		if ( ! Input::get('code') and ($token = Session::get('token')) === null)
		{
			// Redireciona o usuário para a página de autorização do provider
			$provider->authorize();
		}
		/**
		 * Recebemos a resposta do provider com o code, então vamos fazer
		 * a autenticação do usuário em nosso sistema
		 */
		else
		{
			try
			{
				/**
				 * Vamos ver se salvamos já anteriormente
				 */
				if ($token  !== null)
				{
					Debug::dump($token);
					Debug::dump(Date::make($token->expires));
					return;
				}

				/**
				 * Aqui obtemos o token do usuário, com ele podemos fazer
				 * as solicitaçõs no provider, como userinfo e outras
				 * OBS: Devemos salvar este token no banco pra futuras requisições
				 */
				$token = $provider->access(Input::get('code'), Input::get('state'));

				/**
				 * Salvando o token do usuário, não precisamos fazer a solicitação
				 * deste usando o método Provider::access toda vez.
				 */
				Session::set('token', $token);

				// Usando o token, conseguimos capturar as informações do usuário
				$user = $provider->getUserInfo($token);

				// Here you should use this information to A) look for a user B) help a new user sign up with existing data.
				// If you store it all in a cookie and redirect to a registration page this is crazy-simple.
				Debug::dump($user, $token);
			}
			catch (\Exception $e)
			{
				echo 'Ocorreu um erro!';
			}
		}
	}

	public function oauth2fAction(array $params)
	{
		/*
		 * $params[0] - O primeiro parâmetro será o nome do provider
		 * Ex: facebook, twitter, etc
		 */
		$provider_name = $params[0];

		$provider = \Core\Auth\OAuth2\Provider::make($provider_name, array(
			'id' => '160582154038100',
			'secret' => 'e3cdd48ec27c1b2441d5e82b3382af51',
			'redirect_uri' => 'http://127.0.0.2/index/oauth2/' . $provider_name,
		));

		/**
		 * Se não enviou o code, significa que estamos enviando o usuário
		 * para o provider, para depois ele reenviar o usuário para esta
		 * página com o code, isso significa que a resposta veio
		 */
		if ( ! Input::get('code'))
		{
			// Redireciona o usuário para a página de autorização do provider
			$provider->authorize();
		}
		/**
		 * Recebemos a resposta do provider com o code, então vamos fazer
		 * a autenticação do usuário em nosso sistema
		 */
		else
		{
			try
			{
				if (($token = Session::get('token')) !== null)
				{
					\Core\Debug::dump($token);
					\Core\Debug::dump(Date::make($token->expires));
					return;
				}

				/**
				 * Aqui obtemos o token do usuário, com ele podemos fazer
				 * as solicitaçõs no provider, como userinfo e outras
				 * OBS: Devemos salvar este token no banco pra futuras requisições
				 */
				$token = $provider->access(Input::get('code'), Input::get('state'));

				/**
				 * Salvando o token do usuário, não precisamos fazer a solicitação
				 * deste usando o método Provider::access toda vez.
				 */
				Session::set('token', $token);

				// Optional: Use the token object to grab user data from the API
				$user = $provider->getUserInfo($token);

				// Here you should use this information to A) look for a user B) help a new user sign up with existing data.
				// If you store it all in a cookie and redirect to a registration page this is crazy-simple.
				\Core\Debug::dump($user, $token);
			}
			catch (\Core\Auth\OAuth2\ProviderException $e)
			{
				Debug::dump($e);
			}
			catch (\Core\Auth\OAuth2\TokenException $e)
			{
				Debug::dump($e);
			}
		}
	}

	/**
	 * Ação de cadastro
	 *
	 * @param array $params
	 */
	public function cadastroAction($params = null)
	{
		$aid = $this->accountData();
		$this->view->logged = (bool) $aid;

		if( ! $aid)
		{

		}

	}

	/**
	 * Ação de login
	 */
	public function loginAction()
	{
		$userid = \Core\Input::post('userid');
		$passwd = \Core\Input::post('passwd');

		Debug::dump(DB::table('login')->where('userid', '=', $userid)->get());
	}
}
// End of file: <App\Controller\Index.php>

// File: <Core\SessionException.php>

// End of file: <Core\SessionException.php>

// File: <Core\Session.php>
namespace Core;

class SessionException extends \Exception {}

class Session
{
	/**
	 * The session singleton instance for the request.
	 * @var \Core\Session\Driver
	 */
	protected static $_driver = null;

	/**
	 * The session array that is stored by the driver.
	 * @var array
	 */
	protected static $_session = null;

	/**
	 * Store the loaded configs from the system config
	 * @var array
	 */
	protected static $_config = array();

	/**
	 * Create the session driver and load the session.
	 *
	 * return @void
	 */
	public static function _init()
	{
		// Store the configs inside the static array
		static::$_config = Config::get('system.session');

		$driver_name = 'Core\\Session\\' . ucfirst(static::$_config['driver']['name']);

		if( ! class_exists($driver_name))
		{
			throw new SessionException('Session driver "' . $driver_name . '" is not supported.');
		}

		// Load the storage driver
		static::$_driver = new $driver_name(static::$_config['driver']);

		// Load the data for current user
		$id = Cookie::get(static::$_config['cookie']['name']);
		$storage = static::$_driver->load($id);

		// Check for IP or Browser changes
		if($storage !== null and (static::$_config['match_user_agent'] and $storage['browser'] != \Core\Input::userAgent()) or (static::$_config['match_ip'] and $storage['ip'] != Input::ip()))
		{
			static::$_driver->delete($id);
			$storage = null;
		}

		// If all ok, assign the storage to internal session variable
		static::$_session = $storage;

		// If the session doesn't exist or is invalid we will create a new session
		if (is_null(static::$_session) or (time() - static::$_session['last_activity']) > (static::$_config['lifetime'] * 60))
		{
			static::$_session = static::$_driver->create();
		}

		// Save session before sending headers
		Event::register('before_send_headers', 'Core\\Session::save');

		// Load the CSRF token
		Security::loadToken();
	}

	/**
	 * Determine if the session or flash data contains an item.
	 *
	 * @param string $key
	 * @return bool
	 */
	public static function has($key)
	{
		return ( ! is_null(static::get($key)));
	}

	/**
	 * Get an item from the session.
	 *
	 * The session flash data will also be checked for the requested item.
	 *
	 * <code>
	 *		// Get an item from the session
	 *		$name = Session::get('name');
	 *
	 *		// Return a default value if the item doesn't exist
	 *		$name = Session::get('name', 'Taylor');
	 * </code>
	 *
	 * @param string $key
	 * @param mixed $default
	 * @return mixed
	 */
	public static function get($key, $default = null)
	{
		$session = static::$_session['data'];

		// We check for the item in the general session data first, and if it
		// does not exist in that data, we will attempt to find it in the new
		// and old flash data, or finally return the default value.
		if ( ! is_null($value = Arr::get($session, $key)))
		{
			return $value;
		}
		elseif ( ! is_null($value = Arr::get($session[':new:'], $key)))
		{
			return $value;
		}
		elseif ( ! is_null($value = Arr::get($session[':old:'], $key)))
		{
			return $value;
		}

		return value($default);
	}

	/**
	 * Write an item to the session.
	 *
	 * <code>
	 *		// Write an item to the session payload
	 *		Session::set('name', 'Taylor');
	 * </code>
	 *
	 * @param string $key
	 * @param mixed $value
	 * @return void
	 */
	public static function set($key, $value)
	{
		Arr::set(static::$_session['data'], $key, $value);
	}

	/**
	 * Write an item to the session flash data.
	 *
	 * Flash data only exists for the current and next request to the application.
	 *
	 * <code>
	 *		// Write an item to the session payload's flash data
	 *		Session::setFlash('name', 'Taylor');
	 * </code>
	 *
	 * @param string $key
	 * @param mixed $value
	 * @return void
	 */
	public static function setFlash($key, $value)
	{
		Arr::set(static::$_session['data'][':new:'], $key, $value);
	}

	/**
	 * Keep a session flash item from expiring at the end of the request.
	 * If none given, then keep all the flash data
	 *
	 * <code>
	 *		// Keep the "name" item from expiring from the flash data
	 *		Session::keep('name');
	 *
	 *		// Keep the "name" and "email" items from expiring from the flash data
	 *		Session::keep(array('name', 'email'));
	 * </code>
	 *
	 * @param string|array|ArrayAccess $keys
	 * @return void
	 */
	public static function keepFlash($keys = null)
	{
		if($keys === null)
		{
			$old = static::$_session['data'][':old:'];

			static::$_session['data'][':new:'] = array_merge(static::$_session['data'][':new:'], $old);
		}
		else
		{
			foreach ((array) $keys as $key)
			{
				static::flash($key, static::get($key));
			}
		}
	}

	/**
	 * Remove an item from the session data.
	 *
	 * @param string $key
	 * @return void
	 */
	public static function delete($key)
	{
		Arr::delete(static::$_session['data'], $key);
	}

	/**
	 * Remove all of the items from the session.
	 *
	 * The CSRF token will not be removed from the session.
	 *
	 * @return void
	 */
	public static function destroy()
	{
		static::$_session['data'] = array(
			Security::CSRF_TOKEN_KEY => static::$_session['data'][Security::CSRF_TOKEN_KEY],
			':new:' => array(),
			':old:' => array(),
		);
	}

	/**
	 * Assign a new, random ID to the session.
	 *
	 * @return void
	 */
	public static function regenerate()
	{
		static::$_driver->delete(static::$_session['id']);
		static::$_session['id'] = static::$_driver->id();
	}

	/**
	 * Get the last activity for the session.
	 *
	 * @return int
	 */
	public static function getLastActivity()
	{
		return static::$_session['last_activity'];
	}

	/**
	 * Store the session payload in storage.
	 *
	 * This method will be called automatically at the end of the request.
	 *
	 * @return void
	 * @throws \Core\SessionException
	 */
	public static function save()
	{
		if ( ! static::$_driver)
		{
			return;
		}

		static::$_session['last_activity'] = time();

		// Session flash data is only available during the request in which it
		// was flashed and the following request. We will age the data so that
		// it expires at the end of the user's next request.
		static::$_session['data'][':old:'] = static::$_session['data'][':new:'];
		static::$_session['data'][':new:'] = array();

		// The responsibility of actually storing the session information in
		// persistent storage is delegated to the driver instance being used
		// by the session payload.
		//
		// This allows us to keep the payload very generic, while moving the
		// platform or storage mechanism code into the specialized drivers,
		// keeping our code very dry and organized.
		static::$_driver->save(static::$_session, static::$_config);

		// Next we'll write out the session cookie. This cookie contains the
		// ID of the session, and will be used to determine the owner of the
		// session on the user's subsequent requests to the application.
		$minutes = static::$_config['expire_on_close'] ? 0 : time() + static::$_config['lifetime'] * 60;

		Request::getInstance()->setCookie(array(
			'name' => static::$_config['cookie']['name'],
			'value' => static::$_session['id'],
			'expire' => $minutes,
			'path' => static::$_config['cookie']['path'],
			'domain' => static::$_config['cookie']['domain'],
			'secure' => static::$_config['cookie']['secure'],
			'http_only' => static::$_config['cookie']['http_only'],
		));
	}
}
// End of file: <Core\Session.php>

// File: <Core\Session\Driver.php>
namespace Core\Session;

abstract class Driver
{
	/**
	 * Load a session from storage by a given ID.
	 *
	 * If no session is found for the ID, null will be returned.
	 *
	 * @param string $id
	 * @return array
	 */
	abstract public function load($id);

	/**
	 * Save a given session to storage.
	 *
	 * @param array $session
	 * @param array $config
	 * @return void
	 */
	abstract public function save(array $session, array $config);

	/**
	 * Delete a session from storage by a given ID.
	 *
	 * @param string $id
	 * @return void
	 */
	abstract public function delete($id);

	/**
	 * Create a fresh session and return the payload array.
	 *
	 * @return array
	 */
	public function create()
	{
		// We will simply generate an empty session payload array, using an ID
		// that is not currently assigned to any existing session within the
		// application and return it to the driver.
		return array(
			'id' => $this->id(),
			'ip' => \Core\Input::ip(),
			'browser' => \Core\Input::userAgent(),
			'data' => array(
				':new:' => array(),
				':old:' => array(),
			),
		);
	}

	/**
	 * Get a new session ID that isn't assigned to any current session.
	 *
	 * @return string
	 */
	public function id()
	{
		// We'll containue generating random IDs until we find an ID that is
		// not currently assigned to a session. This is almost definitely
		// going to happen on the first iteration.
		do {

			$session = $this->load($id = \Core\Str::random('alnum', 40));

		} while ( ! is_null($session));

		return $id;
	}
}
// End of file: <Core\Session\Driver.php>

// File: <Core\Session\Cache.php>
namespace Core\Session;

class Cache extends Driver
{
	/**
	 * The Cache driver instance.
	 * @var \Core\Cache
	 */
	protected $_cache;

	/**
	 * Create a new cache session driver instance.
	 *
	 * @param array $config
	 */
	public function __construct(array $config)
	{
		$this->_cache = \Core\Cache::getInstance($config['adapter']);
	}

	/**
	 * Load a session from storage by a given ID.
	 *
	 * If no session is found for the ID, null will be returned.
	 *
	 * @param string $id
	 * @return array
	 */
	public function load($id)
	{
		if( ! $this->_cache->has($id))
		{
			return null;
		}

		return $this->_cache->get($id);
	}

	/**
	 * Save a given session to storage.
	 *
	 * @param array $session
	 * @param array $config
	 */
	public function save(array $session, array $config)
	{
		$this->_cache->set($session['id'], $session, $config['lifetime']);
	}

	/**
	 * Delete a session from storage by a given ID.
	 *
	 * @param string $id
	 * @return void
	 */
	public function delete($id)
	{
		$this->_cache->drop($id);
	}
}
// End of file: <Core\Session\Cache.php>

// File: <Core\CacheException.php>

// End of file: <Core\CacheException.php>

// File: <Core\CacheNotFoundException.php>

// End of file: <Core\CacheNotFoundException.php>

// File: <Core\Cache.php>
namespace Core;

class CacheException extends \Exception {}
class CacheNotFoundException extends \Exception {}

class Cache
{
	/**
	 * Already instanced adapters
	 * @var array
	 */
	protected static $_instances = array();

	/**
	 * Get a cache instance from a Cache config file
	 *
	 * @param string $adapter
	 * @return \Core\Cache\Adapter
	 * @throws CacheException
	 */
	public static function getInstance($adapter = 'default')
	{
		if (isset(static::$_instances[$adapter]))
		{
			return static::$_instances[$adapter];
		}

		if ( ! $config = Config::get('cache.' . $adapter))
		{
			throw new CacheException('Cache identifier "' . $adapter . '" not found in Config/Cache.php!');
		}

		// Allow creating custom cache adapters inside App
		if ( ! class_exists($class = 'Core\\Cache\\' . ucfirst($config['adapter'])))
		{
			throw new CacheException('Cache adapter "' . ucfirst($config['adapter']) . '" not found!');
		}

		static::$_instances[$adapter] = new $class($config);
		return static::$_instances[$adapter];
	}

	/**
	 * Check whether some key from cache exists
	 *
	 * @param string $key
	 * @return bool
	 */
	public function has($key)
	{
		return static::getInstance()->has($key);
	}

	/**
	 * Save a value in the cache and set its TTL (Time To Live) in minutes
	 *
	 * @param string $key
	 * @param mixed $value
	 * @param int $minutes
	 * @return \Core\Cache\Adapter $this
	 */
	public function set($key, $value, $minutes = null)
	{
		return static::getInstance()->set($key, $value, $minutes);
	}

	/**
	 * Read a single value from cache
	 *
	 * @param string $key
	 * @return mixed
	 */
	public function get($key)
	{
		return static::getInstance()->get($key);
	}

	/**
	 * Clear a specified key from cache
	 *
	 * @param string $key
	 * @return \Core\Cache\Adapter
	 */
	public function drop($key)
	{
		return static::getInstance()->drop($key);
	}

	/**
	 * Clear all the current cache keys
	 *
	 * @return \Core\Cache\Adapter
	 */
	public function dropAll()
	{
		return static::getInstance()->dropAll();
	}

	/**
	 * Do the garbage collection in the driver
	 *
	 * Only for Database and File drivers
	 *
	 * @return \Core\Cache\Adapter
	 */
	public function garbageCollector()
	{
		return static::getInstance()->garbageCollector();
	}
}
// End of file: <Core\Cache.php>

// File: <Core\Cache\File.php>
namespace Core\Cache;

class File
{
	/**
	 * Namespace of this instance
	 * @var string
	 */
	protected $_namespace = null;

	/**
	 * Current path to the cached files
	 * @var string
	 */
	protected $_path = null;

	/**
	 * Constructor
	 *
	 * @param array $config
	 * @throws \Core\CacheException
	 */
	public function __construct(array $config)
	{
		$this->_path = empty($config['path']) ? APPPATH . 'data' . DS . 'cache' . DS : rtrim($config['path'], '/\\') . DS;
		$this->_namespace = $config['namespace'];

		if ( ! is_dir($this->_path) or ! is_writable($this->_path))
		{
			throw new \Core\CacheException('Cache directory "' . \Core\Debug::cleanPath($this->_path) . '" does not exist or is not writable.');
		}
	}

	/**
	 * Check whether a value exists
	 *
	 * @param string $key
	 * @return bool
	 */
	public function has($key)
	{
		$file_name = $this->_path . $this->_namespace . '_' . md5($key);

		// File based caches store have the expiration timestamp stored in
		// UNIX format prepended to their contents. This timestamp is then
		// extracted and removed when the cache is read to determine if
		// the file is still valid.
		if (is_file($file_name) and time() >= substr($cache = file_get_contents($file_name), 0, 10))
		{
			unlink($file_name);
		}

		return is_file($file_name);
	}


	/**
	 * Retrieve a value from cache
	 *
	 * @param string $key
	 * @return mixed
	 * @throws \Core\CacheNotFoundException
	 */
	public function get($key)
	{
		$file_name = $this->_path . $this->_namespace . '_' . md5($key);

		// File based caches store have the expiration timestamp stored in
		// UNIX format prepended to their contents. This timestamp is then
		// extracted and removed when the cache is read to determine if
		// the file is still valid.
		if (time() >= substr($cache = file_get_contents($file_name), 0, 10))
		{
			unlink($file_name);
		}

		if( ! is_file($file_name))
		{
			throw new \Core\CacheNotFoundException('Cache identifier "' . $key . '" not found or expired!');
		}

		return unserialize(substr($cache, 10));
	}

	/**
	 * Method to set the key in cache
	 *
	 * @param string $key
	 * @param mixed $value
	 * @param int $minutes
	 * @return \Core\Cache\File $this
	 */
	public function set($key, $value, $minutes = null)
	{
		$file_name = $this->_path . $this->_namespace . '_' . md5($key);

		file_put_contents($file_name, ($minutes ? (string) (time() + $minutes * 60) : '9999999999') . serialize(value($value)), LOCK_EX);

		return $this;
	}

	/**
	 * Remove a key from cache
	 *
	 * @param type $key
	 * @return \Core\Cache\File $this
	 */
	public function drop($key)
	{
		$file_name = $this->_path . $this->_namespace . '_' . md5($key);
		is_file($file_name) and unlink($file_name);

		return $this;
	}

	/**
	 * Delete all the keys created by this instance
	 *
	 * @return \Core\Cache\File $this
	 */
	public function dropAll()
	{
		foreach(glob($this->_path . $this->_namespace . '_*') as $file)
		{
			unlink($file);
		}

		return $this;
	}

	/**
	 * Do the garbage collection in the driver
	 *
	 * @return \Core\Cache\File $this
	 */
	public function garbageCollector()
	{
		foreach(glob($this->_path . $this->_namespace . '_*') as $file)
		{
			if (time() >= substr(file_get_contents($file), 0, 10))
			{
				unlink($file);
			}
		}

		return $this;
	}
}
// End of file: <Core\Cache\File.php>

// File: <Core\Cookie.php>
namespace Core;

class Cookie
{

	/**
	 * Cookie class configuration defaults
	 * @var array
	 */
	private static $_config = array(
		'expire' => 0,
		'path' => '/',
		'domain' => null,
		'secure' => false,
		'http_only' => false,
	);

	/*
	 * Initialisation and auto configuration
	 */
	public static function _init()
	{
		static::$_config = static::$_config + Config::get('system.cookie', array());
	}

	/**
	 * Check whether a cookie exists
	 *
	 * @param string Cookie name
	 * @return bool
	 */
	public static function has($name = null)
	{
		return ( ! is_null(Input::cookie($name)));
	}

	/**
	 * Gets the value of a signed cookie. Cookies without signatures will not
	 * be returned. If the cookie signature is present, but invalid, the cookie
	 * will be deleted.
	 *
	 *     // Get the "theme" cookie, or use "blue" if the cookie does not exist
	 *     $theme = Cookie::get('theme', 'blue');
	 *
	 * @param string Cookie name
	 * @param mixed Default value to return
	 * @return string
	 */
	public static function get($name = null, $default = null)
	{
		return Input::cookie($name, $default);
	}

	/**
	 * Sets a signed cookie. Note that all cookie values must be strings and no
	 * automatic serialization will be performed!
	 *
	 *     // Set the "theme" cookie
	 *     Cookie::set('theme', 'red');
	 *
	 * @param string Name of cookie
	 * @param string Value of cookie
	 * @param int Lifetime in minutes
	 * @param string Path of the cookie
	 * @param string Domain of the cookie
	 * @param bool If true, the cookie should only be transmitted over a secure HTTPS connection
	 * @param bool If true, the cookie will be made accessible only through the HTTP protocol
	 * @return bool
	 */
	public static function set($name, $value, $minutes = null, $path = null, $domain = null, $secure = null, $http_only = null)
	{
		$value = value($value);

		// use the class defaults for the other parameters if not provided
		is_null($minutes) and $minutes = static::$_config['expiration'];
		is_null($path) and $path = static::$_config['path'];
		is_null($domain) and $domain = static::$_config['domain'];
		is_null($secure) and $secure = static::$_config['secure'];
		is_null($http_only) and $http_only = static::$_config['http_only'];

		// add the current time so we have an offset
		$minutes = $minutes > 0 ? ($minutes * 60) + time() : 0;

		return Request::getInstance()->setCookie(array(
			'name' => $name,
			'value' => $value,
			'expire' => $minutes,
			'path' => $path,
			'domain' => $domain,
			'secure' => $secure,
			'http_only' => $http_only,
		));
	}

	/**
	 * Deletes a cookie by making the value null and expiring it.
	 *
	 *     Cookie::delete('theme');
	 *
	 * @param string Cookie name
 	 * @param string Path of the cookie
	 * @param string Domain of the cookie
	 * @param bool If true, the cookie should only be transmitted over a secure HTTPS connection
	 * @param bool If true, the cookie will be made accessible only through the HTTP protocol
	 * @return bool
	 */
	public static function delete($name, $path = null, $domain = null, $secure = null, $http_only = null)
	{
		// Remove the cookie
		unset($_COOKIE[$name]);

		// Nullify the cookie and make it expire
		return static::set($name, null, -86400, $path, $domain, $secure, $http_only);
	}
}
// End of file: <Core\Cookie.php>

// File: <Core\DateException.php>

// End of file: <Core\DateException.php>

// File: <Core\Date.php>
namespace Core;

class DateException extends \Exception {}

class Date
{
	/**
	 * Time constants (and only those that are constant, thus not MONTH/YEAR)
	 */
	const WEEK   = 604800;
	const DAY    = 86400;
	const HOUR   = 3600;
	const MINUTE = 60;
	const SECOND = 1;

	/**
	 * Default timezone of the app
	 * @var string
	 */
	protected static $_defaultTimezone = null;

	/**
	 * Datetime instance
	 * @var \DateTime
	 */
	public $datetime = null;

	/**
	 * Set initial default configs
	 */
	public static function _init()
	{
		static::$_defaultTimezone = Config::get('system.timezone', 'UTC');

		// Ugly temporary windows fix because windows doesn't support strptime()
		// Better fix will accept custom pattern parsing but only parse
		// numeric input on windows servers
		if ( ! function_exists('strptime'))
		{
			/**
			 * Implementation of strptime() for PHP on Windows.
			 *
			 * @param string $date
			 * @param string $format
			 * @return array Parsed date
			 */
			function strptime($date, $format)
			{
				// Translate some numeric strftime() format to date's
				$format = strtr($format, array(
					'%d' => 'd',
					'%e' => 'j',
					'%e' => 'j',
					'%w' => 'w',
					'%W' => 'W',
					'%m' => 'm',
					'%y' => 'y',
					'%Y' => 'Y',
					'%H' => 'H',
					'%I' => 'h',
					'%l' => 'g',
					'%M' => 'i',
					'%p' => 'A',
					'%P' => 'a',
					'%r' => 'h:i:s A',
					'%R' => 'h:i',
					'%S' => 's',
					'%T' => 'h:i:s',
					'%z' => 'T',
					'%Z' => 'T',
					'%D' => 'm/d/y',
					'%F' => 'Y-m-d',
					'%s' => 'U',
					'%n' => "\n",
					'%t' => "\t",
					'%%' => '%',
				));

				if ( ! $date = \DateTime::createFromFormat($format, $date))
				{
					return false;
				}

				return localtime($date->getTimestamp(), true);
			}
		}
	}

	/**
	 * Create a new Date instance
	 *
	 * @param null $time Current time
	 * @param int $time Unix timestamp
	 * @param string $time A date/time string. Valid formats are explained in Date and Time Formats.
	 * @param \Core\Date $time A existing Date instance
	 * @param \DateTime $time A native DateTime instance
	 * @param null $timezone Current timezone
	 * @param string $timezone A valid Timezone value
	 * @param \DateTimeZone $timezone A existing native \DateTimeZone instance
	 * @param \Core\Date $timezone A existing Date instance
	 */
	public function __construct($time = null, $timezone = null)
	{
		// Set the internal DateTimeZone instance
		$timezone = static::_getDateTimeZone($timezone);

		// Set the internal DateTime instance
		if ($time instanceof Date)
		{
			$this->datetime = $time->datetime;
		}
		elseif(is_string($time))
		{
			$this->datetime = new \DateTime($time, $timezone);
		}
		elseif(is_int($time))
		{
			$this->datetime = new \DateTime(null, $timezone);
			$this->datetime->setTimestamp($time);
		}
		elseif ($time instanceof \DateTime)
		{
			$this->datetime = clone $time;
		}
		elseif ($time === null)
		{
			$this->datetime = new \DateTime('now', $timezone);
		}
		else
		{
			throw new DateException('Date format type "' . Debug::getType($time) . '" not recognized!');
		}
	}

	/**
	 * Create a new Date instance, timezone is optional
	 *
	 * @param null $time Current time
	 * @param int $time Unix timestamp
	 * @param string $time A date/time string. Valid formats are explained in Date and Time Formats.
	 * @param \Core\Date $time A existing Date instance
	 * @param \DateTime $time A native DateTime instance
	 * @param null $timezone Current timezone
	 * @param string $timezone A valid Timezone value
	 * @param \DateTimeZone $timezone A existing native \DateTimeZone instance
	 * @param \Core\Date $timezone A existing Date instance
	 * @return Date $this
	 */
	public static function make($time = null, $timezone = null)
	{
		return new static($time, $timezone);
	}

	/**
	 * Uses the date config file to translate string input to timestamp
	 *
	 * @param string $input Date/time input
	 * @param string $pattern_key Either a named pattern from date config file or a pattern, defaults to 'local'
	 * @param null $timezone Current timezone
	 * @param string $timezone A valid Timezone value
	 * @param \DateTimeZone $timezone A existing native \DateTimeZone instance
	 * @param \Core\Date $timezone A existing Date instance
	 * @return \Core\Date
	 */
	public static function fromFormat($input, $pattern_key = 'local', $timezone = null)
	{
		$pattern = Config::get('date.patterns.' . $pattern_key, $pattern_key);

		if ( ! $time = strptime($input, $pattern))
		{
			throw new DateException('Invalid date format "' . $input . '" for the pattern "' . $pattern . '".');
		}

		$time = mktime($time['tm_hour'], $time['tm_min'], $time['tm_sec'], $time['tm_mon'] + 1, $time['tm_mday'], $time['tm_year'] + 1900);
		return new static($time, $timezone);
	}

	/**
	 * Returns the date formatted according to the current locale
	 *
	 * @param string Either a named pattern from date config file or a pattern, defaults to 'local'
	 * @param null $timezone Current timezone
	 * @param string $timezone A valid Timezone value
	 * @param \DateTimeZone $timezone A existing native \DateTimeZone instance
	 * @param \Core\Date $timezone A existing Date instance
	 * @param bool $strftime Whether to use stftime instead, to produce locale aware dates
	 * @return string Date formatted
	 */
	public function toFormat($pattern_key = 'local', $timezone = null)
	{
		$pattern = Config::get('date.patterns.' . $pattern_key, $pattern_key);

		$timestamp = $this->datetime->getTimestamp();

		if($timezone !== null)
		{
			$timestamp = $timestamp + static::getTimezoneDifference($timezone);
		}

		// Create output
		$output = strftime($pattern, $timestamp);

		return $output;
	}

	/**
	 * Get a DateTimeZone object from a string, int DateTimeZone or Date object
	 *
	 * @param null $timezone Current timezone
	 * @param string $timezone A valid Timezone value
	 * @param \DateTimeZone $timezone A existing native \DateTimeZone instance
	 * @param \Core\Date $timezone A existing Date instance
	 * @return \DateTimeZone
	 * @throws DateException
	 */
	protected static function _getDateTimeZone($timezone)
	{
		if ($timezone === null)
		{
			$timezone = new \DateTimeZone(static::$_defaultTimezone);
		}
		elseif($timezone instanceof \DateTimeZone)
		{
			// Do nothing
		}
		elseif(is_string($timezone))
		{
			$timezone = new \DateTimeZone($timezone);
		}
		elseif ($timezone instanceof Date)
		{
			$timezone = $timezone->datetime->getTimezone();
		}
		else
		{
			throw new DateException('Timezone format type "' . Debug::getType($timezone) . '" not recognized!');
		}

		return $timezone;
	}

	/**
	 * Set the current timezone
	 *
	 * @param null $timezone Current timezone
	 * @param string $timezone A valid Timezone value
	 * @param \DateTimeZone $timezone A existing native \DateTimeZone instance
	 * @param \Core\Date $timezone A existing Date instance
	 * @return Date $this
	 */
	public function setTimezone($timezone = null)
	{
		$this->datetime->setTimezone(static::_getDateTimeZone($timezone));

		return $this;
	}

	/**
	 * Get the current timezone string
	 *
	 * @return string
	 */
	public function getTimezone()
	{
		return $this->datetime->getTimezone()->getName();
	}

	/**
	 * Returns the current timestamp
	 *
	 * @param int $timestamp
	 * @return Date $this
	 */
	public function setTimestamp($timestamp)
	{
		$this->datetime->setTimestamp($timestamp);
		return $this;
	}

	/**
	 * Returns the current timestamp
	 *
	 * @return int
	 */
	public function getTimestamp()
	{
		return $this->datetime->getTimestamp();
	}

	/**
	 * Alter the timestamp of a DateTime object by incrementing or decrementing
	 * in a format accepted by strtotime().
	 *
	 * @param string $modify
	 * @return \Core\Date $this
	 */
	public function modify($modify)
	{
		$this->datetime->modify($modify);
		return $this;
	}

	/**
	 * Return a DateInterval instance of the difference between these dates
	 *
	 * @param \Core\Date $date
	 * @param \DateTime $date
	 * @param bool $absolute
	 * @return \DateInterval
	 */
	public function diff($date, $absolute = false)
	{
		if ($date instanceof Date)
		{
			$date = $date->datetime;
		}
		elseif ($date instanceof \DateTime)
		{
			// Already a DateTime instance
		}
		else
		{
			throw new DateException('Date format type "' . Debug::getType($date) . '" not recognized!');
		}

		return $this->datetime->diff($date, $absolute);
	}

	/**
	 * Get the difference between two timezones in seconds
	 *
	 * @param null $remote_tz Current timezone
	 * @param string $remote_tz A valid Timezone value
	 * @param \DateTimeZone $remote_tz A existing native \DateTimeZone instance
	 * @param \Core\Date $remote_tz A existing Date instance
	 * @param null $origin_tz Current timezone
	 * @param string $origin_tz A valid Timezone value
	 * @param \DateTimeZone $origin_tz A existing native \DateTimeZone instance
	 * @param \Core\Date $origin_tz A existing Date instance
	 * @return int
	 */
	public static function getTimezoneDifference($remote_tz, $origin_tz = null)
	{
		$origin_dtz = static::_getDateTimeZone($remote_tz);
		$remote_dtz = static::_getDateTimeZone($origin_tz);

		return $origin_dtz->getOffset(new \DateTime('now', $origin_dtz)) - $remote_dtz->getOffset(new \DateTime('now', $remote_dtz));
	}

	/**
	 * Fetches an array of Date objects per interval within a range
	 *
	 * @param null $start Current time
	 * @param int $start Unix timestamp
	 * @param string $start A date/time string. Valid formats are explained in Date and Time Formats.
	 * @param \Core\Date $start A existing Date instance
	 * @param \DateTime $start A native DateTime instance
	 * @param null $end Current time
	 * @param int $end Unix timestamp
	 * @param string $end A date/time string. Valid formats are explained in Date and Time Formats.
	 * @param \Core\Date $end A existing Date instance
	 * @param \DateTime $end A native DateTime instance
	 * @param string $interval Length of the interval in seconds
	 * @param int $interval A valid strtotime time difference
	 * @return array Array of Date objects
	 */
	public static function rangeToArray($start, $end, $interval = '+1 Day')
	{
		if ( ! $start instanceof Date)
		{
			$start = new static($start);
		}

		if ( ! $end instanceof Date)
		{
			$end = new static($end);
		}

		is_int($interval) or $interval = strtotime($interval, $start->getTimestamp()) - $start->getTimestamp();

		if ($interval <= 0)
		{
			throw new \UnexpectedValueException('Input was not recognized by pattern.');
		}

		$range   = array();
		$current = $start;

		while ($current->getTimestamp() <= $end->getTimestamp())
		{
			$range[] = $current;
			$current = new static($current->getTimestamp() + $interval);
		}

		return $range;
	}

	/**
	 * Returns the number of days in the requested month
	 *
	 * @param int Month as a number (1-12)
	 * @param int The year, leave empty for current
	 * @return int The number of days in the month
	 */
	public static function daysInMonth($month, $year = null)
	{
		$year  = ! empty($year) ? (int) $year : (int) date('Y');
		$month = (int) $month;

		if ($month < 1 or $month > 12)
		{
			throw new \UnexpectedValueException('Invalid input for month given.');
		}
		elseif ($month == 2 and ($year % 400 == 0 or ($year % 4 == 0 and $year % 100 != 0)))
		{
			return 29;
		}

		$days_in_month = array(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);
		return $days_in_month[$month-1];
	}

	/**
	 * Returns the time ago
	 *
	 * @param int $timestamp Unix timestamp
	 * @param string $timestamp A date/time string. Valid formats are explained in Date and Time Formats.
	 * @param \Core\Date $timestamp A existing Date instance
	 * @param \DateTime $timestamp A native DateTime instance
	 * @param int $from_timestamp Unix timestamp to compare against
	 * @param string $from_timestamp A date/time string. Valid formats are explained in Date and Time Formats.
	 * @param \Core\Date $from_timestamp A existing Date instance
	 * @param \DateTime $from_timestamp A native DateTime instance
	 * @return string Time ago
	 */
	public static function timeAgo($timestamp, $from_timestamp = null)
	{
		if ($timestamp === null)
		{
			return '';
		}

		! is_numeric($timestamp) and $timestamp = static::make($timestamp)->getTimestamp();

		if ($from_timestamp === null)
		{
			$from_timestamp = time();
		}
		elseif( ! is_numeric($from_timestamp))
		{
			$from_timestamp = static::make($from_timestamp)->getTimestamp();
		}

		// Get the difference between the timestamps
		$difference = $from_timestamp - $timestamp;

		if ($difference < 3)
		{
			return Lang::get('date.now');
		}

		$periods = array(
			12 * 30 * 24 * 60 * 60 => 'year',
			30 * 24 * 60 * 60 => 'month',
			24 * 60 * 60 => 'day',
			60 * 60 => 'hour',
			60 => 'minute',
			1 => 'second'
		);

		foreach ($periods as $secs => $str)
		{
			$time = $difference / $secs;
			if ($time >= 1)
			{
				$number = round($time);
				return $number . ' ' . Lang::get('date.' . ($number > 1 ? $str . 's' : $str));
			}
		}
	}

	/**
	 * Allows you to just put the object in a string and get it inserted in the default pattern
	 *
	 * @return string
	 */
	public function __toString()
	{
		return $this->toFormat();
	}

	/**
	 * Allows you to just put the object in a SQL query and get it inserted in the default pattern
	 *
	 * @return string
	 */
	public function __toSql($driver)
	{
		return $this->toFormat('sql.' . $driver);
	}
}
// End of file: <Core\Date.php>

// File: <Core\Security.php>
namespace Core;

class Security
{
	/**
	 * The token as submitted in the cookie from the previous request
	 * @var string
	 */
	protected static $_csrfOldToken = null;

	/**
	 * The token for the next request
	 * @var string
	 */
	protected static $_csrfToken = null;

	/**
	 * The string name of the CSRF token stored in the session.
	 * @var string
	 */
	const CSRF_TOKEN_KEY = 'csrf_token';

	/**
	 * Cleans the global $_GET, $_POST and $_COOKIE arrays
	 *
	 * @return void
	 */
	public static function cleanInput()
	{
		$_GET = static::clean($_GET);
		$_POST = static::clean($_POST);
		$_COOKIE = static::clean($_COOKIE);
	}

	/**
	 * Generic variable clean method
	 *
	 * @param mixed $var
	 * @param array|null $filters All the function filters to clean the values - Can be a callable or a Regex string
	 * @return mixed
	 */
	public static function clean($var, $filters = null)
	{
		is_null($filters) and $filters = Config::get('system.security.input_filter', array());
		is_array($filters) or $filters = array($filters);

		foreach ($filters as $filter)
		{
			// Is this filter a callable function?
			if (is_callable($filter))
			{
				if (is_array($var))
				{
					foreach($var as $key => $value)
					{
						$var[$key] = call_user_func($filter, $value);
					}
				}
				else
				{
					$var = call_user_func($filter, $var);
				}
			}

			// Assume it's a regex of characters to filter
			else
			{
				if (is_array($var))
				{
					foreach($var as $key => $value)
					{
						$var[$key] = preg_replace('#['.$filter.']#ui', '', $value);
					}
				}
				else
				{
					$var = preg_replace('#['.$filter.']#ui', '', $var);
				}
			}
		}
		return $var;
	}

	/**
	 * Clean the input value with the anti XSS injection
	 *
	 * @param array|string $value
	 * @return array|string
	 */
	public static function xssClean($value)
	{
		if ( ! is_array($value))
		{
			if ( ! function_exists('htmLawed'))
			{
				include COREPATH . 'Vendor' . DS . 'htmLawed' . DS . 'htmLawed.php';
			}

			return htmLawed($value, array('safe' => 1, 'balanced' => 0));
		}

		foreach ($value as &$element)
		{
			$element = static::xssClean($element);
		}

		return $value;
	}

	/**
	 * Strip all HTML tags from the value
	 *
	 * @param string|array $value
	 * @return string|array
	 */
	public static function stripTags($value)
	{
		if ( ! is_array($value))
		{
			$value = filter_var($value, FILTER_SANITIZE_STRING);
		}
		else
		{
			foreach ($value as &$element)
			{
				$element = static::stripTags($element);
			}
		}

		return $value;
	}

	/**
	 * Escape all the special HTML characters into its entities
	 *
	 * @param string|array $value
	 * @param int $flags Htmlentities flags to use
	 * @return string|array
	 * @throws \RuntimeException
	 */
	public static function htmlEntities($value, $flags = null)
	{
		is_null($flags) and $flags = Config::get('system.security.htmlentities_flags', ENT_QUOTES);

		// Nothing to escape for non-string scalars
		if (is_bool($value) or is_int($value) or is_float($value))
		{
			return $value;
		}

		if (is_string($value))
		{
			$value = htmlentities($value, $flags, Config::get('system.encoding'), false);
		}
		elseif (is_array($value) or ($value instanceof \Iterator and $value instanceof \ArrayAccess))
		{
			foreach ($value as $k => $v)
			{
				$value->{$k} = static::htmlEntities($v, $flags);
			}
		}
		elseif ($value instanceof \Iterator or get_class($value) == 'stdClass')
		{
			foreach ($value as $k => $v)
			{
				$value->{$k} = static::htmlEntities($v, $flags);
			}
		}
		elseif (is_object($value))
		{
			// Check if the object is whitelisted and return when that's the case
			foreach (Config::get('system.security.whitelisted_classes', array()) as $class)
			{
				if (is_a($value, $class))
				{
					return $value;
				}
			}

			// Throw exception when it wasn't whitelisted and can't be converted to String
			if ( ! method_exists($value, '__toString'))
			{
				throw new \RuntimeException('Object class "'.get_class($value).'" could not be converted to string or '.
					'sanitized as ArrayAccess. Whitelist it in security.whitelisted_classes in APPPATH/Config/System.php '.
					'to allow it to be passed unchecked.');
			}

			$value = static::htmlEntities((string) $value, $flags);
		}

		return $value;
	}

	/**
	 * Hash a password using the Bcrypt hashing scheme.
	 *
	 * <code>
	 *		// Create a Bcrypt hash of a value
	 *		$hash = Hash::make('secret');
	 *
	 *		// Use a specified number of iterations when creating the hash
	 *		$hash = Hash::make('secret', 12);
	 * </code>
	 *
	 * @param string $value
	 * @param int $rounds
	 * @return string
	 */
	public static function hash($value, $rounds = 8)
	{
		$work = str_pad($rounds, 2, '0', STR_PAD_LEFT);

		// Bcrypt expects the salt to be 22 base64 encoded characters including
		// dots and slashes. We will get rid of the plus signs included in the
		// base64 data and replace them with dots.
		if (function_exists('openssl_random_pseudo_bytes'))
		{
			$salt = openssl_random_pseudo_bytes(16);
		}
		else
		{
			$salt = Str::random(40);
		}

		$salt = substr(strtr(base64_encode($salt), '+', '.'), 0 , 22);

		return crypt($value, '$2a$'.$work.'$'.$salt);
	}

	/**
	 * Determine if an unhashed value matches a Bcrypt hash.
	 *
	 * @param string $value
	 * @param string $hash
	 * @return bool
	 */
	public static function checkHash($value, $hash)
	{
		return (bool) (strcmp(crypt($value, $hash), $hash) == 0);
	}

	/**
	 * Fetches CSRF settings and current token
	 *
	 * @return void
	 */
	public static function loadToken()
	{
		static::$_csrfOldToken = Session::get(static::CSRF_TOKEN_KEY);
		static::checkToken();
	}

	/**
	 * Check CSRF Token
	 * Check token also ensures a token is present and will reset the
	 * token for the next session when it receives a value to check
	 * (no matter the result of the check).
	 *
	 * @param string CSRF token to be checked, checks post when empty
	 * @return bool
	 */
	public static function checkToken($value = null)
	{
		$value or $value = Input::post(static::CSRF_TOKEN_KEY, 'fail');

		// Always reset token once it's been checked and still the same
		if (strcmp(static::fetchToken(), static::$_csrfOldToken) == 0 and ! empty($value))
		{
			static::_setToken(true);
		}

		return (bool) (strcmp($value, static::$_csrfOldToken) == 0);
	}

	/**
	 * Fetch CSRF Token for the next request
	 *
	 * @return string
	 */
	public static function fetchToken()
	{
		if (static::$_csrfToken !== null)
		{
			return static::$_csrfToken;
		}


		static::_setToken();

		return static::$_csrfToken;
	}

	/**
	 * Set the current token and send cookie
	 *
	 * @param bool $reset If true, resend the cookie always
	 * @return void
	 */
	protected static function _setToken($reset = false)
	{
		// re-use old token when found (= not expired) and expiration is used (otherwise always reset)
		if ( ! $reset and static::$_csrfOldToken)
		{
			static::$_csrfToken = static::$_csrfOldToken;
		}
		// set new token for next session when necessary
		else
		{
			static::$_csrfToken = sha1(uniqid() . microtime(true));
			Session::set(static::CSRF_TOKEN_KEY, static::$_csrfToken);
		}
	}
}
// End of file: <Core\Security.php>

// File: <Core\Debug\FirePHP.php>
// Authors:
// - cadorn, Christoph Dorn <christoph@christophdorn.com>, Copyright 2007, New BSD License
// - qbbr, Sokolov Innokenty <sokolov.innokenty@gmail.com>, Copyright 2011, New BSD License
// - cadorn, Christoph Dorn <christoph@christophdorn.com>, Copyright 2011, MIT License

/**
 * *** BEGIN LICENSE BLOCK *****
 *
 * [MIT License](http://www.opensource.org/licenses/mit-license.php)
 *
 * Copyright (c) 2007+ [Christoph Dorn](http://www.christophdorn.com/)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * ***** END LICENSE BLOCK *****
 *
 * @copyright	   Copyright (C) 2007+ Christoph Dorn
 * @author		  Christoph Dorn <christoph@christophdorn.com>
 * @license		 [MIT License](http://www.opensource.org/licenses/mit-license.php)
 * @package		 FirePHPCore
 */

/**
 * Sends the given data to the FirePHP Firefox Extension.
 * The data can be displayed in the Firebug Console or in the
 * "Server" request tab.
 *
 * For more information see: http://www.firephp.org/
 *
 * @copyright	   Copyright (C) 2007+ Christoph Dorn
 * @author		  Christoph Dorn <christoph@christophdorn.com>
 * @license		 [MIT License](http://www.opensource.org/licenses/mit-license.php)
 * @package		 FirePHPCore
 */

namespace Core\Debug;

class FirePHP {

	/**
	 * FirePHP version
	 *
	 * @var string
	 */
	const VERSION = '1.0b1rc1-coffee';

	/**
	 * Firebug LOG level
	 *
	 * Logs a message to firebug console.
	 *
	 * @var string
	 */
	const LOG = 'LOG';

	/**
	 * Firebug INFO level
	 *
	 * Logs a message to firebug console and displays an info icon before the message.
	 *
	 * @var string
	 */
	const INFO = 'INFO';

	/**
	 * Firebug WARN level
	 *
	 * Logs a message to firebug console, displays an warning icon before the message and colors the line turquoise.
	 *
	 * @var string
	 */
	const WARN = 'WARN';

	/**
	 * Firebug ERROR level
	 *
	 * Logs a message to firebug console, displays an error icon before the message and colors the line yellow. Also increments the firebug error count.
	 *
	 * @var string
	 */
	const ERROR = 'ERROR';

	/**
	 * Dumps a variable to firebug's server panel
	 *
	 * @var string
	 */
	const DUMP = 'DUMP';

	/**
	 * Displays a stack trace in firebug console
	 *
	 * @var string
	 */
	const TRACE = 'TRACE';

	/**
	 * Displays an exception in firebug console
	 *
	 * Increments the firebug error count.
	 *
	 * @var string
	 */
	const EXCEPTION = 'EXCEPTION';

	/**
	 * Displays an table in firebug console
	 *
	 * @var string
	 */
	const TABLE = 'TABLE';

	/**
	 * Starts a group in firebug console
	 *
	 * @var string
	 */
	const GROUP_START = 'GROUP_START';

	/**
	 * Ends a group in firebug console
	 *
	 * @var string
	 */
	const GROUP_END = 'GROUP_END';

	/**
	 * Singleton instance of FirePHP
	 *
	 * @var FirePHP
	 */
	protected static $instance = null;

	/**
	 * Wildfire protocol message index
	 *
	 * @var integer
	 */
	protected $messageIndex = 1;

	/**
	 * Options for the library
	 *
	 * @var array
	 */
	protected $options = array('maxDepth' => 10,
							   'maxObjectDepth' => 5,
							   'maxArrayDepth' => 5,
							   'useNativeJsonEncode' => true);

	/**
	 * Filters used to exclude object members when encoding
	 *
	 * @var array
	 */
	protected $objectFilters = array(
		'firephp' => array('objectStack', 'instance', 'json_objectStack'),
		'firephp_test_class' => array('objectStack', 'instance', 'json_objectStack')
	);

	/**
	 * A stack of objects used to detect recursion during object encoding
	 *
	 * @var object
	 */
	protected $objectStack = array();

	/**
	 * Flag to enable/disable logging
	 *
	 * @var boolean
	 */
	protected $enabled = true;

	/**
	 * When the object gets serialized only include specific object members.
	 *
	 * @return array
	 */
	public function __sleep()
	{
		return array('options', 'objectFilters', 'enabled');
	}

	/**
	 * Deixar o construtor privado para evitar mais de uma instância
	 * Singleton pattern
	 */
	protected function __construct(){}

	/**
	 * Gets singleton instance of FirePHP
	 *
	 * @param boolean $autoCreate
	 * @return FirePHP
	 */
	public static function getInstance()
	{
		if ( ! static::$instance)
			static::$instance = new static;

		return static::$instance;
	}

	/**
	 * Enable and disable logging to Firebug
	 *
	 * @param boolean $enabled TRUE to enable, FALSE to disable
	 * @return void
	 */
	public function setEnabled($enabled)
	{
	   $this->enabled = $enabled;
	}

	/**
	 * Check if logging is enabled
	 *
	 * @return boolean TRUE if enabled
	 */
	public function getEnabled()
	{
		return $this->enabled;
	}

	/**
	 * Specify a filter to be used when encoding an object
	 *
	 * Filters are used to exclude object members.
	 *
	 * @param string $class The class name of the object
	 * @param array $filter An array of members to exclude
	 * @return void
	 */
	public function setObjectFilter($class, $filter)
	{
		$this->objectFilters[strtolower($class)] = $filter;
	}

	/**
	 * Set some options for the library
	 *
	 * Options:
	 *  - maxDepth: The maximum depth to traverse (default: 10)
	 *  - maxObjectDepth: The maximum depth to traverse objects (default: 5)
	 *  - maxArrayDepth: The maximum depth to traverse arrays (default: 5)
	 *  - useNativeJsonEncode: If true will use json_encode() (default: true)
	 *
	 * @param array $options The options to be set
	 * @return void
	 */
	public function setOptions($options)
	{
		$this->options = array_merge($this->options, $options);
	}

	/**
	 * Get options from the library
	 *
	 * @return array The currently set options
	 */
	public function getOptions()
	{
		return $this->options;
	}

	/**
	 * Set an option for the library
	 *
	 * @param string $name
	 * @param mixed $value
	 * @return void
	 * @throws Exception
	 */
	public function setOption($name, $value)
	{
		if (!isset($this->options[$name])) {
			throw new \Exception('Unknown option: ' . $name);
		}
		$this->options[$name] = $value;
	}

	/**
	 * Get an option from the library
	 *
	 * @param string $name
	 * @return mixed
	 * @throws Exception
	 */
	public function getOption($name)
	{
		if (!isset($this->options[$name])) {
			throw new \Exception('Unknown option: ' . $name);
		}
		return $this->options[$name];
	}

	/**
	 * Start a group for following messages.
	 *
	 * Options:
	 *   Collapsed: [true|false]
	 *   Color:	 [#RRGGBB|ColorName]
	 *
	 * @param string $name
	 * @param array $options OPTIONAL Instructions on how to log the group
	 * @return true
	 * @throws Exception
	 */
	public function group($name, $options = null)
	{

		if (!$name) {
			throw new \Exception('You must specify a label for the group!');
		}

		if ($options) {
			if (!is_array($options)) {
				throw new \Exception('Options must be defined as an array!');
			}
			if (array_key_exists('Collapsed', $options)) {
				$options['Collapsed'] = ($options['Collapsed']) ? 'true' : 'false';
			}
		}

		return $this->fb(null, $name, FirePHP::GROUP_START, $options);
	}

	/**
	 * Ends a group you have started before
	 *
	 * @return true
	 * @throws Exception
	 */
	public function groupEnd()
	{
		return $this->fb(null, null, FirePHP::GROUP_END);
	}

	/**
	 * Log object with label to firebug console
	 *
	 * @see FirePHP::LOG
	 * @param mixes $object
	 * @param string $label
	 * @return true
	 * @throws Exception
	 */
	public function log($object, $label = null, $options = array())
	{
		return $this->fb($object, $label, FirePHP::LOG, $options);
	}

	/**
	 * Log object with label to firebug console
	 *
	 * @see FirePHP::INFO
	 * @param mixes $object
	 * @param string $label
	 * @return true
	 * @throws Exception
	 */
	public function info($object, $label = null, $options = array())
	{
		return $this->fb($object, $label, FirePHP::INFO, $options);
	}

	/**
	 * Log object with label to firebug console
	 *
	 * @see FirePHP::WARN
	 * @param mixes $object
	 * @param string $label
	 * @return true
	 * @throws Exception
	 */
	public function warn($object, $label = null, $options = array())
	{
		return $this->fb($object, $label, FirePHP::WARN, $options);
	}

	/**
	 * Log object with label to firebug console
	 *
	 * @see FirePHP::ERROR
	 * @param mixes $object
	 * @param string $label
	 * @return true
	 * @throws Exception
	 */
	public function error($object, $label = null, $options = array())
	{
		return $this->fb($object, $label, FirePHP::ERROR, $options);
	}

	/**
	 * Dumps key and variable to firebug server panel
	 *
	 * @see FirePHP::DUMP
	 * @param string $key
	 * @param mixed $variable
	 * @return true
	 * @throws Exception
	 */
	public function dump($key, $variable, $options = array())
	{
		if (!is_string($key)) {
			throw new \Exception('Key passed to dump() is not a string');
		}
		if (strlen($key) > 100) {
			throw new \Exception('Key passed to dump() is longer than 100 characters');
		}
		if (!preg_match_all('/^[a-zA-Z0-9-_\.:]*$/', $key, $m)) {
			throw new \Exception('Key passed to dump() contains invalid characters [a-zA-Z0-9-_\.:]');
		}
		return $this->fb($variable, $key, FirePHP::DUMP, $options);
	}

	/**
	 * Log a trace in the firebug console
	 *
	 * @see FirePHP::TRACE
	 * @param string $label
	 * @return true
	 * @throws Exception
	 */
	public function trace($label)
	{
		return $this->fb($label, FirePHP::TRACE);
	}

	/**
	 * Log a table in the firebug console
	 *
	 * @see FirePHP::TABLE
	 * @param string $label
	 * @param string $table
	 * @return true
	 * @throws Exception
	 */
	public function table($label, $table, $options = array())
	{
		return $this->fb($table, $label, FirePHP::TABLE, $options);
	}

	/**
	 * Check if FirePHP is installed on client
	 *
	 * @return boolean
	 */
	public function detectClientExtension()
	{
		// Check if FirePHP is installed on client via User-Agent header
		if (@preg_match_all('/\sFirePHP\/([\.\d]*)\s?/si', $this->getUserAgent(), $m) &&
			version_compare($m[1][0], '0.0.6', '>=')) {
			return true;
		} else
		// Check if FirePHP is installed on client via X-FirePHP-Version header
		if (@preg_match_all('/^([\.\d]*)$/si', $this->getRequestHeader('X-FirePHP-Version'), $m) &&
			version_compare($m[1][0], '0.0.6', '>=')) {
			return true;
		}
		return false;
	}

	/**
	 * Log varible to Firebug
	 *
	 * @see http://www.firephp.org/Wiki/Reference/Fb
	 * @param mixed $object The variable to be logged
	 * @return boolean Return TRUE if message was added to headers, FALSE otherwise
	 * @throws Exception
	 */
	public function fb($object)
	{
		if (!$this->getEnabled() or !$this->detectClientExtension()) {
			return false;
		}

		$type = null;
		$label = null;
		$options = array();

		if (func_num_args() == 1) {
		} else if (func_num_args() == 2) {
			switch (func_get_arg(1)) {
				case static::LOG:
				case static::INFO:
				case static::WARN:
				case static::ERROR:
				case static::DUMP:
				case static::TRACE:
				case static::EXCEPTION:
				case static::TABLE:
				case static::GROUP_START:
				case static::GROUP_END:
					$type = func_get_arg(1);
					break;
				default:
					$label = func_get_arg(1);
					break;
			}
		} else if (func_num_args() == 3) {
			$type = func_get_arg(2);
			$label = func_get_arg(1);
		} else if (func_num_args() == 4) {
			$type = func_get_arg(2);
			$label = func_get_arg(1);
			$options = func_get_arg(3);
		} else {
			throw new \Exception('Wrong number of arguments to fb() function!');
		}

		$skipFinalObjectEncode = false;

		if ($object instanceof Exception) {

			$trace = $object->getTrace();
			$file = \Core\Debug::cleanPath($object->getFile());
			$line = $object->getLine();

			$object = array(
				'Class' => get_class($object),
				'Message' => $file.' @ line: '.$line.' - '.$object->getMessage(),
				'File' => $file,
				'Line' => $line,
				'Type' => 'throw',
				'Trace' => $this->_escapeTrace($trace)
			);
			$skipFinalObjectEncode = true;
			$type = static::EXCEPTION;

		} else if ($type == static::TRACE) {
			$trace = $object ? $object : debug_backtrace();
			if (!$trace) return false;
			$i = 0;
			$object = array(
				'Class' => isset($trace[$i]['class']) ? $trace[$i]['class'] : '',
				'Type' => isset($trace[$i]['type']) ? $trace[$i]['type'] : '',
				'Function' => isset($trace[$i]['function']) ? $trace[$i]['function'] : '',
				'Message' => $label,
				'File' => isset($trace[$i]['file']) ? \Core\Debug::cleanPath($trace[$i]['file']) : '',
				'Line' => isset($trace[$i]['line']) ? $trace[$i]['line'] : '',
				'Args' => isset($trace[$i]['args']) ? $this->encodeObject($trace[$i]['args']) : '',
				'Trace' => $this->_escapeTrace(array_splice($trace, $i + 1)),
			);

			$skipFinalObjectEncode = true;

		} else
		if ($type == static::TABLE) {

			if (isset($object[0]) && is_string($object[0])) {
				$object[1] = $this->encodeTable($object[1]);
			} else {
				$object = $this->encodeTable($object);
			}

			$skipFinalObjectEncode = true;

		} else if ($type == static::GROUP_START) {

			if (!$label) {
				throw new \Exception('You must specify a label for the group!');
			}

		} else {
			if ($type === null) {
				$type = static::LOG;
			}
		}

		$this->setHeader('X-Wf-Protocol-1', 'http://meta.wildfirehq.org/Protocol/JsonStream/0.2');
		$this->setHeader('X-Wf-1-Plugin-1', 'http://meta.firephp.org/Wildfire/Plugin/FirePHP/Library-FirePHPCore/' . static::VERSION);

		$structureIndex = 1;
		if ($type == static::DUMP) {
			$structureIndex = 2;
			$this->setHeader('X-Wf-1-Structure-2', 'http://meta.firephp.org/Wildfire/Structure/FirePHP/Dump/0.1');
		} else {
			$this->setHeader('X-Wf-1-Structure-1', 'http://meta.firephp.org/Wildfire/Structure/FirePHP/FirebugConsole/0.1');
		}

		if ($type == static::DUMP) {
			$msg = '{"' . $label . '":' . $this->jsonEncode($object, $skipFinalObjectEncode) . '}';
		} else {
			$msgMeta = $options;
			$msgMeta['Type'] = $type;
			if ($label !== null) {
				$msgMeta['Label'] = $label;
			}
			$msg = '[' . $this->jsonEncode($msgMeta) . ',' . $this->jsonEncode($object, $skipFinalObjectEncode) . ']';
		}

		$parts = explode("\n", chunk_split($msg, 5000, "\n"));

		for ($i = 0; $i < count($parts); $i++) {

			$part = $parts[$i];
			if ($part) {

				if (count($parts) > 2) {
					// Message needs to be split into multiple parts
					$this->setHeader('X-Wf-1-' . $structureIndex . '-' . '1-' . $this->messageIndex,
									 (($i == 0) ? strlen($msg) : '')
									 . '|' . $part . '|'
									 . (($i < count($parts) - 2) ? '\\' : ''));
				} else {
					$this->setHeader('X-Wf-1-' . $structureIndex . '-' . '1-' . $this->messageIndex,
									 strlen($part) . '|' . $part . '|');
				}

				$this->messageIndex++;

				if ($this->messageIndex > 99999) {
					throw new \Exception('Maximum number (99,999) of messages reached!');
				}
			}
		}

		$this->setHeader('X-Wf-1-Index', $this->messageIndex - 1);

		return true;
	}

	/**
	 * Standardizes path for windows systems.
	 *
	 * @param string $path
	 * @return string
	 */
	protected function _standardizePath($path)
	{
		return preg_replace('/\\\\+/', '/', $path);
	}

	/**
	 * Escape trace path for windows systems
	 *
	 * @param array $trace
	 * @return array
	 */
	protected function _escapeTrace($trace)
	{
		if (!$trace) return $trace;
		for ($i = 0; $i < sizeof($trace); $i++) {
			if (isset($trace[$i]['file'])) {
				$trace[$i]['file'] = \Core\Debug::cleanPath($this->_escapeTraceFile($trace[$i]['file']));
			}
			if (isset($trace[$i]['args'])) {
				$trace[$i]['args'] = $this->encodeObject($trace[$i]['args']);
			}
		}
		return $trace;
	}

	/**
	 * Escape file information of trace for windows systems
	 *
	 * @param string $file
	 * @return string
	 */
	protected function _escapeTraceFile($file)
	{
		/* Check if we have a windows filepath */
		if (strpos($file, '\\')) {
			/* First strip down to single \ */

			$file = preg_replace('/\\\\+/', '\\', $file);

			return $file;
		}
		return $file;
	}

	/**
	 * Set header for sending later
	 *
	 * @param string $header
	 * @param string $value
	 */
	protected function setHeader($header, $value)
	{
		\Core\Request::getInstance()->setHeader($header, $value);
	}

	/**
	 * Get user agent
	 *
	 * @return string|false
	 */
	protected function getUserAgent()
	{
		if (!isset($_SERVER['HTTP_USER_AGENT'])) return false;
		return $_SERVER['HTTP_USER_AGENT'];
	}

	/**
	 * Get all request headers
	 *
	 * @return array
	 */
	public static function getAllRequestHeaders()
	{
		static $_cachedHeaders = false;
		if ($_cachedHeaders !== false) {
			return $_cachedHeaders;
		}
		$headers = array();
		if (function_exists('getallheaders')) {
			foreach (getallheaders() as $name => $value) {
				$headers[strtolower($name)] = $value;
			}
		} else {
			foreach ($_SERVER as $name => $value) {
				if (substr($name, 0, 5) == 'HTTP_') {
					$headers[strtolower(str_replace(' ', '-', str_replace('_', ' ', substr($name, 5))))] = $value;
				}
			}
		}
		return $_cachedHeaders = $headers;
	}

	/**
	 * Get a request header
	 *
	 * @return string|false
	 */
	protected function getRequestHeader($name)
	{
		$headers = static::getAllRequestHeaders();
		if (isset($headers[strtolower($name)])) {
			return $headers[strtolower($name)];
		}
		return false;
	}

	/**
	 * Encode an object into a JSON string
	 *
	 * Uses PHP's jeson_encode() if available
	 *
	 * @param object $object The object to be encoded
	 * @param boolean $skipObjectEncode
	 * @return string The JSON string
	 */
	public function jsonEncode($object, $skipObjectEncode = false)
	{
		if (!$skipObjectEncode) {
			$object = $this->encodeObject($object);
		}

		if (function_exists('json_encode')
		   && $this->options['useNativeJsonEncode'] != false) {
			return json_encode($object);
		} else {
			return $this->json_encode($object);
		}
	}

	/**
	 * Encodes a table by encoding each row and column with encodeObject()
	 *
	 * @param array $table The table to be encoded
	 * @return array
	 */
	protected function encodeTable($table)
	{
		if (!$table) return $table;

		$newTable = array();
		foreach ($table as $row) {

			if (is_array($row)) {
				$newRow = array();

				foreach ($row as $item) {
					$newRow[] = $this->encodeObject($item);
				}

				$newTable[] = $newRow;
			}
		}

		return $newTable;
	}

	/**
	 * Encodes an object including members with
	 * protected and private visibility
	 *
	 * @param object $object The object to be encoded
	 * @param integer $Depth The current traversal depth
	 * @return array All members of the object
	 */
	protected function encodeObject($object, $objectDepth = 1, $arrayDepth = 1, $maxDepth = 1)
	{
		if ($maxDepth > $this->options['maxDepth']) {
			return '** Max Depth (' . $this->options['maxDepth'] . ') **';
		}

		$return = array();

		if (is_resource($object)) {

			return '** ' . (string) $object . ' **';

		} else if (is_object($object)) {

			if ($objectDepth > $this->options['maxObjectDepth']) {
				return '** Max Object Depth (' . $this->options['maxObjectDepth'] . ') **';
			}

			foreach ($this->objectStack as $refVal) {
				if ($refVal === $object) {
					return '** Recursion (' . get_class($object) . ') **';
				}
			}
			array_push($this->objectStack, $object);

			$return['__className'] = $class = get_class($object);
			$classLower = strtolower($class);

			$reflectionClass = new \ReflectionClass($class);
			$properties = array();
			foreach ($reflectionClass->getProperties() as $property) {
				$properties[$property->getName()] = $property;
			}

			$members = (array)$object;

			foreach ($properties as $plainName => $property) {

				$name = $rawName = $plainName;
				if ($property->isStatic()) {
					$name = 'static:' . $name;
				}
				if ($property->isPublic()) {
					$name = 'public:' . $name;
				} else if ($property->isPrivate()) {
					$name = 'private:' . $name;
					$rawName = "\0" . $class . "\0" . $rawName;
				} else if ($property->isProtected()) {
					$name = 'protected:' . $name;
					$rawName = "\0" . '*' . "\0" . $rawName;
				}

				if (!(isset($this->objectFilters[$classLower])
					 && is_array($this->objectFilters[$classLower])
					 && in_array($plainName, $this->objectFilters[$classLower]))) {

					if (array_key_exists($rawName, $members) && !$property->isStatic()) {
						$return[$name] = $this->encodeObject($members[$rawName], $objectDepth + 1, 1, $maxDepth + 1);
					} else {
						if (method_exists($property, 'setAccessible')) {
							$property->setAccessible(true);
							$return[$name] = $this->encodeObject($property->getValue($object), $objectDepth + 1, 1, $maxDepth + 1);
						} else
						if ($property->isPublic()) {
							$return[$name] = $this->encodeObject($property->getValue($object), $objectDepth + 1, 1, $maxDepth + 1);
						} else {
							$return[$name] = '** Need PHP 5.3 to get value **';
						}
					}
				} else {
					$return[$name] = '** Excluded by Filter **';
				}
			}

			// Include all members that are not defined in the class
			// but exist in the object
			foreach ($members as $rawName => $value) {

				$name = $rawName;

				if ($name{0} == "\0") {
					$parts = explode("\0", $name);
					$name = $parts[2];
				}

				$plainName = $name;

				if (!isset($properties[$name])) {
					$name = 'undeclared:' . $name;

					if (!(isset($this->objectFilters[$classLower])
						 && is_array($this->objectFilters[$classLower])
						 && in_array($plainName, $this->objectFilters[$classLower]))) {

						$return[$name] = $this->encodeObject($value, $objectDepth + 1, 1, $maxDepth + 1);
					} else {
						$return[$name] = '** Excluded by Filter **';
					}
				}
			}

			array_pop($this->objectStack);

		} elseif (is_array($object)) {

			if ($arrayDepth > $this->options['maxArrayDepth']) {
				return '** Max Array Depth (' . $this->options['maxArrayDepth'] . ') **';
			}

			foreach ($object as $key => $val) {

				// Encoding the $GLOBALS PHP array causes an infinite loop
				// if the recursion is not reset here as it contains
				// a reference to itself. This is the only way I have come up
				// with to stop infinite recursion in this case.
				if ($key == 'GLOBALS'
				   && is_array($val)
				   && array_key_exists('GLOBALS', $val)) {
					$val['GLOBALS'] = '** Recursion (GLOBALS) **';
				}

				if (!$this->is_utf8($key)) {
					$key = utf8_encode($key);
				}

				$return[$key] = $this->encodeObject($val, 1, $arrayDepth + 1, $maxDepth + 1);
			}
		} else {
			if ($this->is_utf8($object)) {
				return $object;
			} else {
				return utf8_encode($object);
			}
		}
		return $return;
	}

	/**
	 * Returns true if $string is valid UTF-8 and false otherwise.
	 *
	 * @param mixed $str String to be tested
	 * @return boolean
	 */
	protected function is_utf8($str)
	{
		if (function_exists('mb_detect_encoding')) {
			return (
				mb_detect_encoding($str, 'UTF-8', true) == 'UTF-8' &&
				($str === null || $this->jsonEncode($str, true) !== 'null')
			);
		}
		$c = 0;
		$b = 0;
		$bits = 0;
		$len = strlen($str);
		for ($i = 0; $i < $len; $i++) {
			$c = ord($str[$i]);
			if ($c > 128) {
				if (($c >= 254)) return false;
				elseif ($c >= 252) $bits = 6;
				elseif ($c >= 248) $bits = 5;
				elseif ($c >= 240) $bits = 4;
				elseif ($c >= 224) $bits = 3;
				elseif ($c >= 192) $bits = 2;
				else return false;
				if (($i + $bits) > $len) return false;
				while($bits > 1) {
					$i++;
					$b = ord($str[$i]);
					if ($b < 128 || $b > 191) return false;
					$bits--;
				}
			}
		}
		return ($str === null || $this->jsonEncode($str, true) !== 'null');
	}

	/**
	 * Converts to and from JSON format.
	 *
	 * JSON (JavaScript Object Notation) is a lightweight data-interchange
	 * format. It is easy for humans to read and write. It is easy for machines
	 * to parse and generate. It is based on a subset of the JavaScript
	 * Programming Language, Standard ECMA-262 3rd Edition - December 1999.
	 * This feature can also be found in  Python. JSON is a text format that is
	 * completely language independent but uses conventions that are familiar
	 * to programmers of the C-family of languages, including C, C++, C#, Java,
	 * JavaScript, Perl, TCL, and many others. These properties make JSON an
	 * ideal data-interchange language.
	 *
	 * This package provides a simple encoder and decoder for JSON notation. It
	 * is intended for use with client-side Javascript applications that make
	 * use of HTTPRequest to perform server communication functions - data can
	 * be encoded into JSON notation for use in a client-side javascript, or
	 * decoded from incoming Javascript requests. JSON format is native to
	 * Javascript, and can be directly eval()'ed with no further parsing
	 * overhead
	 *
	 * All strings should be in ASCII or UTF-8 format!
	 *
	 * LICENSE: Redistribution and use in source and binary forms, with or
	 * without modification, are permitted provided that the following
	 * conditions are met: Redistributions of source code must retain the
	 * above copyright notice, this list of conditions and the following
	 * disclaimer. Redistributions in binary form must reproduce the above
	 * copyright notice, this list of conditions and the following disclaimer
	 * in the documentation and/or other materials provided with the
	 * distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
	 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
	 * NO EVENT SHALL CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
	 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
	 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
	 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
	 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
	 * DAMAGE.
	 *
	 * @category
	 * @package	 Services_JSON
	 * @author	  Michal Migurski <mike-json@teczno.com>
	 * @author	  Matt Knapp <mdknapp[at]gmail[dot]com>
	 * @author	  Brett Stimmerman <brettstimmerman[at]gmail[dot]com>
	 * @author	  Christoph Dorn <christoph@christophdorn.com>
	 * @copyright   2005 Michal Migurski
	 * @version	 CVS: $Id: JSON.php,v 1.31 2006/06/28 05:54:17 migurski Exp $
	 * @license	 http://www.opensource.org/licenses/bsd-license.php
	 * @link		http://pear.php.net/pepr/pepr-proposal-show.php?id=198
	 */


	/**
	 * Keep a list of objects as we descend into the array so we can detect recursion.
	 */
	private $json_objectStack = array();


   /**
	* convert a string from one UTF-8 char to one UTF-16 char
	*
	* Normally should be handled by mb_convert_encoding, but
	* provides a slower PHP-only method for installations
	* that lack the multibye string extension.
	*
	* @param	string  $utf8   UTF-8 character
	* @return   string  UTF-16 character
	* @access   private
	*/
	private function json_utf82utf16($utf8)
	{
		// oh please oh please oh please oh please oh please
		if (function_exists('mb_convert_encoding')) {
			return mb_convert_encoding($utf8, 'UTF-16', 'UTF-8');
		}

		switch (strlen($utf8)) {
			case 1:
				// this case should never be reached, because we are in ASCII range
				// see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
				return $utf8;

			case 2:
				// return a UTF-16 character from a 2-byte UTF-8 char
				// see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
				return chr(0x07 & (ord($utf8{0}) >> 2))
					   . chr((0xC0 & (ord($utf8{0}) << 6))
					   | (0x3F & ord($utf8{1})));

			case 3:
				// return a UTF-16 character from a 3-byte UTF-8 char
				// see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
				return chr((0xF0 & (ord($utf8{0}) << 4))
					   | (0x0F & (ord($utf8{1}) >> 2)))
					   . chr((0xC0 & (ord($utf8{1}) << 6))
					   | (0x7F & ord($utf8{2})));
		}

		// ignoring UTF-32 for now, sorry
		return '';
	}

   /**
	* encodes an arbitrary variable into JSON format
	*
	* @param	mixed   $var	any number, boolean, string, array, or object to be encoded.
	*						   see argument 1 to Services_JSON() above for array-parsing behavior.
	*						   if var is a strng, note that encode() always expects it
	*						   to be in ASCII or UTF-8 format!
	*
	* @return   mixed   JSON string representation of input var or an error if a problem occurs
	* @access   public
	*/
	private function json_encode($var)
	{
		if (is_object($var)) {
			if (in_array($var, $this->json_objectStack)) {
				return '"** Recursion **"';
			}
		}

		switch (gettype($var)) {
			case 'boolean':
				return $var ? 'true' : 'false';

			case 'NULL':
				return 'null';

			case 'integer':
				return (int) $var;

			case 'double':
			case 'float':
				return (float) $var;

			case 'string':
				// STRINGS ARE EXPECTED TO BE IN ASCII OR UTF-8 FORMAT
				$ascii = '';
				$strlen_var = strlen($var);

			   /*
				* Iterate over every character in the string,
				* escaping with a slash or encoding to UTF-8 where necessary
				*/
				for ($c = 0; $c < $strlen_var; ++$c) {

					$ord_var_c = ord($var{$c});

					switch (true) {
						case $ord_var_c == 0x08:
							$ascii .= '\b';
							break;
						case $ord_var_c == 0x09:
							$ascii .= '\t';
							break;
						case $ord_var_c == 0x0A:
							$ascii .= '\n';
							break;
						case $ord_var_c == 0x0C:
							$ascii .= '\f';
							break;
						case $ord_var_c == 0x0D:
							$ascii .= '\r';
							break;

						case $ord_var_c == 0x22:
						case $ord_var_c == 0x2F:
						case $ord_var_c == 0x5C:
							// double quote, slash, slosh
							$ascii .= '\\' . $var{$c};
							break;

						case (($ord_var_c >= 0x20) && ($ord_var_c <= 0x7F)):
							// characters U-00000000 - U-0000007F (same as ASCII)
							$ascii .= $var{$c};
							break;

						case (($ord_var_c & 0xE0) == 0xC0):
							// characters U-00000080 - U-000007FF, mask 110XXXXX
							// see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
							$char = pack('C*', $ord_var_c, ord($var{$c + 1}));
							$c += 1;
							$utf16 = $this->json_utf82utf16($char);
							$ascii .= sprintf('\u%04s', bin2hex($utf16));
							break;

						case (($ord_var_c & 0xF0) == 0xE0):
							// characters U-00000800 - U-0000FFFF, mask 1110XXXX
							// see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
							$char = pack('C*', $ord_var_c,
										 ord($var{$c + 1}),
										 ord($var{$c + 2}));
							$c += 2;
							$utf16 = $this->json_utf82utf16($char);
							$ascii .= sprintf('\u%04s', bin2hex($utf16));
							break;

						case (($ord_var_c & 0xF8) == 0xF0):
							// characters U-00010000 - U-001FFFFF, mask 11110XXX
							// see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
							$char = pack('C*', $ord_var_c,
										 ord($var{$c + 1}),
										 ord($var{$c + 2}),
										 ord($var{$c + 3}));
							$c += 3;
							$utf16 = $this->json_utf82utf16($char);
							$ascii .= sprintf('\u%04s', bin2hex($utf16));
							break;

						case (($ord_var_c & 0xFC) == 0xF8):
							// characters U-00200000 - U-03FFFFFF, mask 111110XX
							// see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
							$char = pack('C*', $ord_var_c,
										 ord($var{$c + 1}),
										 ord($var{$c + 2}),
										 ord($var{$c + 3}),
										 ord($var{$c + 4}));
							$c += 4;
							$utf16 = $this->json_utf82utf16($char);
							$ascii .= sprintf('\u%04s', bin2hex($utf16));
							break;

						case (($ord_var_c & 0xFE) == 0xFC):
							// characters U-04000000 - U-7FFFFFFF, mask 1111110X
							// see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
							$char = pack('C*', $ord_var_c,
										 ord($var{$c + 1}),
										 ord($var{$c + 2}),
										 ord($var{$c + 3}),
										 ord($var{$c + 4}),
										 ord($var{$c + 5}));
							$c += 5;
							$utf16 = $this->json_utf82utf16($char);
							$ascii .= sprintf('\u%04s', bin2hex($utf16));
							break;
					}
				}

				return '"' . $ascii . '"';

			case 'array':
				/*
				 * As per JSON spec if any array key is not an integer
				 * we must treat the the whole array as an object. We
				 * also try to catch a sparsely populated associative
				 * array with numeric keys here because some JS engines
				 * will create an array with empty indexes up to
				 * max_index which can cause memory issues and because
				 * the keys, which may be relevant, will be remapped
				 * otherwise.
				 *
				 * As per the ECMA and JSON specification an object may
				 * have any string as a property. Unfortunately due to
				 * a hole in the ECMA specification if the key is a
				 * ECMA reserved word or starts with a digit the
				 * parameter is only accessible using ECMAScript's
				 * bracket notation.
				 */

				// treat as a JSON object
				if (is_array($var) && count($var) && (array_keys($var) !== range(0, sizeof($var) - 1))) {

					$this->json_objectStack[] = $var;

					$properties = array_map(array($this, 'json_name_value'),
											array_keys($var),
											array_values($var));

					array_pop($this->json_objectStack);

					foreach ($properties as $property) {
						if ($property instanceof Exception) {
							return $property;
						}
					}

					return '{' . join(',', $properties) . '}';
				}

				$this->json_objectStack[] = $var;

				// treat it like a regular array
				$elements = array_map(array($this, 'json_encode'), $var);

				array_pop($this->json_objectStack);

				foreach ($elements as $element) {
					if ($element instanceof Exception) {
						return $element;
					}
				}

				return '[' . join(',', $elements) . ']';

			case 'object':
				$vars = static::encodeObject($var);

				$this->json_objectStack[] = $var;

				$properties = array_map(array($this, 'json_name_value'),
										array_keys($vars),
										array_values($vars));

				array_pop($this->json_objectStack);

				foreach ($properties as $property) {
					if ($property instanceof Exception) {
						return $property;
					}
				}

				return '{' . join(',', $properties) . '}';

			default:
				return null;
		}
	}

   /**
	* array-walking function for use in generating JSON-formatted name-value pairs
	*
	* @param	string  $name   name of key to use
	* @param	mixed   $value  reference to an array element to be encoded
	*
	* @return   string  JSON-formatted name-value pair, like '"name":value'
	* @access   private
	*/
	private function json_name_value($name, $value)
	{
		// Encoding the $GLOBALS PHP array causes an infinite loop
		// if the recursion is not reset here as it contains
		// a reference to itself. This is the only way I have come up
		// with to stop infinite recursion in this case.
		if ($name == 'GLOBALS'
		   && is_array($value)
		   && array_key_exists('GLOBALS', $value)) {
			$value['GLOBALS'] = '** Recursion **';
		}

		$encodedValue = $this->json_encode($value);

		if ($encodedValue instanceof Exception) {
			return $encodedValue;
		}

		return $this->json_encode(strval($name)) . ':' . $encodedValue;
	}
}
// End of file: <Core\Debug\FirePHP.php>

// Autoload the cached classes
$classes = ['Core\\Loader', 'Core\\LoaderException', 'Core\\ConfigException', 'Core\\Config', 'Core\\Profiler', 'Core\\Event', 'Core\\Error', 'Core\\RequestException', 'Core\\HttpNotFoundException', 'Core\\Request', 'Core\\Router', 'Core\\URL', 'Core\\Input', 'Core\\Arr', 'Core\\Route', 'Core\\Controller\\Basic', 'App\\Controller\\Index', 'Core\\SessionException', 'Core\\Session', 'Core\\Session\\Driver', 'Core\\Session\\Cache', 'Core\\CacheException', 'Core\\CacheNotFoundException', 'Core\\Cache', 'Core\\Cache\\File', 'Core\\Cookie', 'Core\\DateException', 'Core\\Date', 'Core\\Security', 'Core\\Debug\\FirePHP'];

foreach ($classes as $class) {
	if (method_exists($class, '_init'))
	{
		$class::_init();
	}
}